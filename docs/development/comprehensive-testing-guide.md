# Comprehensive Testing Guide

## Table of Contents

1. [Overview](#overview)
2. [Testing Philosophy](#testing-philosophy)
3. [Testing Frameworks & Tools](#testing-frameworks--tools)
4. [Test Types & Strategies](#test-types--strategies)
5. [Test Structure & Organization](#test-structure--organization)
6. [Testing Utilities & Helpers](#testing-utilities--helpers)
7. [Advanced Testing Techniques](#advanced-testing-techniques)
8. [Best Practices](#best-practices)
9. [Common Patterns](#common-patterns)
10. [Troubleshooting](#troubleshooting)

## Overview

This guide provides comprehensive documentation for testing in the macro-ai client-ui application. Our testing strategy
emphasizes practical, valuable tests that provide confidence in code quality while maintaining developer productivity.

### Testing Goals

- **Quality Assurance**: Catch bugs before they reach production
- **Documentation**: Tests serve as living documentation of expected behavior
- **Refactoring Safety**: Enable confident refactoring with comprehensive test coverage
- **Developer Experience**: Fast, reliable tests that don't impede development flow
- **User Experience Validation**: Ensure UI components work correctly with real API interactions

## Testing Philosophy

Our testing approach aligns with the guidelines in `CLAUDE.md`:

### Core Principles

1. **Focus on Value**: Write tests that provide real value, not just coverage numbers
2. **Test Behavior**: Test what the code does, not how it does it
3. **Realistic Scenarios**: Use realistic test data and scenarios
4. **Maintainability**: Tests should be easy to understand and maintain
5. **Fast Feedback**: Tests should run quickly to enable rapid development cycles

### What NOT to Test

- **Autogenerated Code**: API clients, route trees, and other generated files
- **Third-party Libraries**: Assume they are tested by their maintainers
- **Trivial Code**: Simple getters, setters, and pass-through functions
- **Pure Presentational Components**: Focus on components with business logic
- **External APIs**: Use MSW for mocking external API interactions
- **Browser APIs**: Mock browser APIs and focus on application logic

## Testing Frameworks & Tools

### Core Testing Stack

- **Vitest**: Primary test runner and assertion library with parallel execution
- **React Testing Library**: For React component testing with accessibility focus
- **MSW (Mock Service Worker)**: Network-level API mocking and interception
- **TanStack Router Testing**: Custom utilities for router testing with authentication
- **Component Test Utils**: Enhanced form and interaction testing utilities
- **Faker.js**: Realistic test data generation for comprehensive scenarios

### Additional Tools

- **User Event**: Realistic user interactions for form testing
- **Vitest Mock Extended**: Enhanced mocking capabilities with TypeScript support
- **Test Data Factories**: Structured test data generation
- **Coverage Tools**: v8 provider with detailed reporting and thresholds

## Test Types & Strategies

### 1. Unit Tests

**Purpose**: Test individual functions, hooks, and utilities in isolation

**When to Use**:

- Custom React hooks with business logic
- Utility functions and data transformations
- Service layer logic and API client methods
- Form validation and data processing functions
- Router guards and authentication logic

**Example**:

```typescript
import { describe, it, expect } from 'vitest'
import { useAuthState } from '../hooks/useAuthState'
import { renderHook } from '@testing-library/react'

describe('useAuthState', () => {
	it('should return authenticated state when token exists', () => {
		// Mock localStorage
		Object.defineProperty(window, 'localStorage', {
			value: {
				getItem: vi.fn(() => 'valid-token'),
			},
		})

		const { result } = renderHook(() => useAuthState())

		expect(result.current.isAuthenticated).toBe(true)
		expect(result.current.token).toBe('valid-token')
	})
})
```

### 2. Integration Tests

**Purpose**: Test how multiple components work together with real API interactions

**When to Use**:

- Component interactions with API calls
- Form submissions with backend validation
- Router navigation with authentication
- Complex user workflows spanning multiple components
- API error handling in component context

**Example**:

```typescript
import { describe, it, expect } from 'vitest'
import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { setupMSWForTests } from '../test/msw-setup'

describe('User Registration Integration', () => {
	setupMSWForTests()

	it('should handle complete registration workflow', async () => {
		const user = userEvent.setup()
		render(<RegistrationForm />)

		// Fill out the registration form
		await user.type(screen.getByLabelText(/email/i), 'user@example.com')
		await user.type(screen.getByLabelText(/password/i), 'password123')
		await user.type(screen.getByLabelText(/confirm password/i), 'password123')

		// Submit the form
		await user.click(screen.getByRole('button', { name: /register/i }))

		// Verify success message appears
		await waitFor(() => {
			expect(screen.getByText(/registration successful/i)).toBeInTheDocument()
		})

		// Verify user is redirected to dashboard
		await waitFor(() => {
			expect(window.location.pathname).toBe('/dashboard')
		})
	})
})
```

### 3. Component Contract Tests

**Purpose**: Verify component interfaces and prop contracts

**When to Use**:

- Component prop validation and type safety
- Component interface stability
- Breaking change detection in component APIs
- Integration between parent and child components

**Example**:

````typescript
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import { UserProfile } from '../components/UserProfile'

describe('UserProfile Component Contract', () => {
	it('should handle required props correctly', () => {
		const user = {
			id: '123',
			email: 'user@example.com',
			firstName: 'John',
			lastName: 'Doe',
		}

		render(<UserProfile user={user} onUpdate={vi.fn()} />)

		expect(screen.getByText('John Doe')).toBeInTheDocument()
		expect(screen.getByText('user@example.com')).toBeInTheDocument()
	})

	it('should call onUpdate when edit button is clicked', async () => {
		const user = {
			id: '123',
			email: 'user@example.com',
			firstName: 'John',
			lastName: 'Doe',
		}
		const onUpdate = vi.fn()

		const userEvent = userEvent.setup()
		render(<UserProfile user={user} onUpdate={onUpdate} />)

		await userEvent.click(screen.getByRole('button', { name: /edit/i }))

		expect(onUpdate).toHaveBeenCalledWith(user)
	})

	it('should handle loading state', () => {
		render(<UserProfile loading={true} onUpdate={vi.fn()} />)

		expect(screen.getByText(/loading/i)).toBeInTheDocument()
		expect(screen.queryByRole('button')).not.toBeInTheDocument()
	})
})

### 4. Performance Tests

**Purpose**: Verify performance characteristics and identify bottlenecks

**When to Use**:

- Critical path operations
- Database query performance
- API response times
- Memory usage validation

**Example**:

```typescript
import { PerformanceTester } from '../test-helpers'

describe('Database Performance', () => {
	it('should perform user queries within acceptable time', async () => {
		const performanceTester = new PerformanceTester()

		const results = await performanceTester.runPerformanceTest(
			'userQuery',
			async () => await getUserById('user-123'),
			{
				iterations: 100,
				warmup: 10,
				measureMemory: true,
			},
		)

		expect(results.summary.avgDuration).toBeLessThan(50) // 50ms max
		expect(results.summary.throughput).toBeGreaterThan(20) // 20 ops/sec min
	})
})
````

## Test Structure & Organization

### File Organization

```text
src/
├── features/
│   └── auth/
│       ├── __tests__/
│       │   ├── auth.controller.test.ts
│       │   ├── auth.service.test.ts
│       │   └── auth.routes.integration.test.ts
│       ├── auth.controller.ts
│       ├── auth.service.ts
│       └── auth.routes.ts
└── utils/
    └── test-helpers/
        ├── __tests__/
        │   ├── database-integration.example.test.ts
        │   ├── advanced-mocking.example.test.ts
        │   └── pact-contract.example.test.ts
        ├── database-integration.ts
        ├── advanced-mocking.ts
        ├── pact-contract-testing.ts
        └── index.ts
```

### Naming Conventions

- **Unit Tests**: `*.test.ts` - Tests for individual functions/modules
- **Integration Tests**: `*.integration.test.ts` - Tests for component interactions
- **Example Tests**: `*.example.test.ts` - Demonstration and documentation tests
- **Mock Files**: `*.mock.ts` - Mock implementations and factories

### Test Structure Pattern

```typescript
describe('Feature/Component Name', () => {
	// Setup and teardown
	beforeAll(async () => {
		// Global setup
	})

	beforeEach(() => {
		// Test-specific setup
	})

	afterEach(() => {
		// Test-specific cleanup
	})

	afterAll(async () => {
		// Global cleanup
	})

	// Group related tests
	describe('Specific Functionality', () => {
		it('should handle normal case', () => {
			// Test implementation
		})

		it('should handle edge case', () => {
			// Test implementation
		})

		it('should handle error case', () => {
			// Test implementation
		})
	})
})
```

## Testing Utilities & Helpers

### Database Integration Testing

```typescript
import {
	setupDatabaseIntegration,
	cleanupGlobalResources,
} from './test-helpers'

// Setup real database for integration tests
const dbContext = await setupDatabaseIntegration({
	useTestcontainers: true,
	runMigrations: true,
	seedTestData: true,
})

// Use in tests
const user = await dbContext.db.insert(usersTable).values(userData).returning()
```

### Time-Based Testing

```typescript
import { TimeController } from './test-helpers'

const timeController = new TimeController({
	useFakeTimers: true,
	autoAdvance: false,
})

// Control time in tests
timeController.start()
setTimeout(operation, 5000)
timeController.advance(5000) // Fast-forward 5 seconds
timeController.stop()
```

### Error Simulation

```typescript
import { ErrorSimulator } from './test-helpers'

const errorSimulator = new ErrorSimulator({
	probability: 0.1,
	errorTypes: ['network', 'database', 'validation'],
})

// Test error handling
const resilientFunction = errorSimulator.wrapWithErrorSimulation(
	async () => ({ success: true }),
	'network',
)
```

### Mock Data Generation

```typescript
import { MockDataFactory, createMockData } from './test-helpers'

// Generate realistic test data
const user = MockDataFactory.createUser({
	email: 'test@example.com',
})

const users = MockDataFactory.createArray(
	() => MockDataFactory.createUser(),
	10,
	{ department: 'Engineering' },
)

// Using convenience functions
const chat = createMockData.chat({ title: 'Test Chat' })
const apiResponse = createMockData.apiResponse(user)
```

## Advanced Testing Techniques

### 1. Parameterized Testing

```typescript
describe.each([
	{ input: 'valid@email.com', expected: true },
	{ input: 'invalid-email', expected: false },
	{ input: '', expected: false },
])('Email validation with $input', ({ input, expected }) => {
	it(`should return ${expected}`, () => {
		expect(validateEmail(input)).toBe(expected)
	})
})
```

### 2. Snapshot Testing

```typescript
it('should match API response snapshot', async () => {
	const response = await request(app).get('/api/users/123').expect(200)

	expect(response.body).toMatchSnapshot()
})
```

### 3. Property-Based Testing

```typescript
import { fc } from 'fast-check'

it('should validate all email formats', () => {
	fc.assert(
		fc.property(fc.emailAddress(), (email) => {
			expect(validateEmail(email)).toBe(true)
		}),
	)
})
```

### 4. Mutation Testing

```typescript
it('should handle concurrent modifications', async () => {
	const user = await createUser()

	const updates = await Promise.allSettled([
		updateUser(user.id, { firstName: 'John' }),
		updateUser(user.id, { lastName: 'Doe' }),
		updateUser(user.id, { email: 'new@example.com' }),
	])

	expect(updates.every((u) => u.status === 'fulfilled')).toBe(true)
})
```

## Best Practices

### 1. Test Data Management

```typescript
// ✅ Good: Use factories for consistent test data
const user = MockDataFactory.createUser({
	email: 'test@example.com',
})

// ❌ Avoid: Hardcoded test data scattered throughout tests
const user = {
	id: 'user-123',
	email: 'test@example.com',
	firstName: 'John',
	// ... many fields
}
```

### 2. Assertion Quality

```typescript
// ✅ Good: Specific, meaningful assertions
expect(response.status).toBe(201)
expect(response.body.data.email).toBe(userData.email)
expect(response.body.data.id).toMatch(/^[0-9a-f-]{36}$/)

// ❌ Avoid: Vague or overly broad assertions
expect(response).toBeTruthy()
expect(response.body).toBeDefined()
```

### 3. Error Testing

```typescript
// ✅ Good: Test specific error scenarios
it('should handle invalid email format', async () => {
	await expect(createUser({ email: 'invalid' })).rejects.toThrow(
		'Invalid email format',
	)
})

// ✅ Good: Test error recovery
it('should retry on network failure', async () => {
	const mockFetch = vi
		.fn()
		.mockRejectedValueOnce(new Error('Network error'))
		.mockResolvedValueOnce({ ok: true, json: () => ({ success: true }) })

	const result = await resilientApiCall()
	expect(mockFetch).toHaveBeenCalledTimes(2)
	expect(result.success).toBe(true)
})
```

### 4. Test Isolation

```typescript
// ✅ Good: Each test is independent
beforeEach(async () => {
	await cleanDatabase()
	await seedTestData()
})

// ✅ Good: Use transactions for database tests
await transactionTester.withTransaction(async (client) => {
	// Test operations that will be rolled back
	await createUser(userData)
	// Test assertions
})
```

### 5. Async Testing

```typescript
// ✅ Good: Proper async/await usage
it('should handle async operations', async () => {
	const result = await asyncOperation()
	expect(result).toBeDefined()
})

// ✅ Good: Test timing with fake timers
it('should handle delayed operations', async () => {
	timeController.start()

	const promise = delayedOperation(5000)
	timeController.advance(5000)

	const result = await promise
	expect(result).toBe('completed')

	timeController.stop()
})
```

## Common Patterns

### 1. Database Testing Pattern

```typescript
describe('User Data Access', () => {
	let dbContext: DatabaseTestContext

	beforeAll(async () => {
		dbContext = await setupDatabaseIntegration()
	})

	afterAll(async () => {
		await cleanupGlobalResources()
	})

	beforeEach(async () => {
		await dbContext.seedTestData()
	})

	it('should create user', async () => {
		const userData = MockDataFactory.createUser()
		const [user] = await dbContext.db
			.insert(usersTable)
			.values(userData)
			.returning()

		expect(user.email).toBe(userData.email)
	})
})
```

### 2. API Testing Pattern

```typescript
describe('User API', () => {
	let app: Express
	let dbContext: DatabaseTestContext

	beforeAll(async () => {
		dbContext = await setupDatabaseIntegration()
		app = createServer(dbContext.db)
	})

	afterAll(async () => {
		await cleanupGlobalResources()
	})

	it('should create user via API', async () => {
		const userData = {
			email: 'test@example.com',
			firstName: 'John',
			lastName: 'Doe',
		}

		const response = await request(app)
			.post('/api/users')
			.send(userData)
			.expect(201)

		expect(response.body.data.email).toBe(userData.email)
	})
})
```

### 3. Service Mocking Pattern

```typescript
describe('User Service', () => {
	let userService: UserService
	let mockDb: MockedDatabase

	beforeEach(() => {
		mockDb = createMockDatabase()
		userService = new UserService(mockDb)
	})

	it('should handle database errors gracefully', async () => {
		mockDb.insert.mockRejectedValue(new Error('Database connection failed'))

		await expect(userService.createUser(userData)).rejects.toThrow(
			'Failed to create user',
		)
	})
})
```

### 4. Time-Dependent Testing Pattern

```typescript
describe('Scheduled Operations', () => {
	let timeController: TimeController

	beforeEach(() => {
		timeController = new TimeController()
		timeController.start()
	})

	afterEach(() => {
		timeController.stop()
	})

	it('should execute scheduled task', async () => {
		const task = vi.fn()
		scheduleTask(task, 60000) // 1 minute

		// Fast-forward time
		timeController.advance(60000)
		await timeController.waitForTimers()

		expect(task).toHaveBeenCalledOnce()
	})
})
```

### 5. Error Recovery Testing Pattern

```typescript
describe('Resilient Service', () => {
	let errorSimulator: ErrorSimulator

	beforeEach(() => {
		errorSimulator = new ErrorSimulator({
			probability: 0.3,
			errorTypes: ['network', 'timeout'],
		})
		errorSimulator.start()
	})

	afterEach(() => {
		errorSimulator.stop()
	})

	it('should retry on transient failures', async () => {
		const service = new ResilientService()

		// Test multiple times to trigger error scenarios
		for (let i = 0; i < 10; i++) {
			const result = await service.performOperation()
			expect(result.success).toBe(true)
		}
	})
})
```

## Test Configuration

### Vitest Configuration

```typescript
// vitest.config.ts
export default defineConfig({
	test: {
		environment: 'node',
		globals: true,
		setupFiles: ['./vitest.setup.ts'],
		coverage: {
			provider: 'v8',
			reporter: ['text', 'json', 'html', 'lcov'],
			thresholds: {
				global: {
					statements: 80,
					branches: 75,
					functions: 80,
					lines: 80,
				},
			},
		},
	},
})
```

### Test Setup

```typescript
// vitest.setup.ts
import { beforeAll, afterAll } from 'vitest'
import { setupMSW } from './test-helpers/msw-setup'

beforeAll(async () => {
	// Global test setup
	await setupMSW()
})

afterAll(async () => {
	// Global test cleanup
	await cleanupGlobalResources()
})
```

## Troubleshooting

### Common Issues

#### 1. Tests Timing Out

**Symptoms**: Tests hang or timeout
**Solutions**:

- Use fake timers for time-dependent tests
- Ensure proper cleanup in afterEach/afterAll
- Check for unresolved promises
- Add explicit timeouts to long-running tests

```typescript
it('should complete within time limit', async () => {
	// Add explicit timeout
}, 10000) // 10 second timeout
```

#### 2. Database Connection Issues

**Symptoms**: "Connection pool exhausted" or "Too many connections"
**Solutions**:

- Properly close database connections
- Use connection pooling
- Clean up test containers

```typescript
afterAll(async () => {
	await dbContext.cleanup()
	await cleanupGlobalResources()
})
```

#### 3. Flaky Tests

**Symptoms**: Tests pass/fail inconsistently
**Solutions**:

- Use deterministic test data
- Control time with fake timers
- Ensure proper test isolation
- Avoid race conditions

```typescript
// ✅ Good: Deterministic
faker.seed(12345)
const user = MockDataFactory.createUser()

// ✅ Good: Controlled timing
timeController.start()
timeController.advance(1000)
```

#### 4. Memory Leaks in Tests

**Symptoms**: Tests slow down over time, memory usage increases
**Solutions**:

- Clean up event listeners
- Stop timers and intervals
- Close database connections
- Clear mocks and spies

```typescript
afterEach(() => {
	vi.clearAllMocks()
	timeController.stop()
	errorSimulator.stop()
})
```

## Coverage Guidelines

### Coverage Targets

- **Statements**: 80% minimum
- **Branches**: 75% minimum
- **Functions**: 80% minimum
- **Lines**: 80% minimum

### Coverage Exclusions

- Autogenerated files (`**/*.gen.ts`)
- Configuration files (`**/*.config.*`)
- Type definition files (`**/*.d.ts`)
- Test files themselves (`**/*.test.ts`, `**/*.spec.ts`)
- Main entry points (`**/main.tsx`, `**/main.ts`)

### Coverage Analysis

```bash
# Generate coverage report
pnpm test:coverage

# Analyze coverage gaps
pnpm test:coverage:analyze

# Open coverage report in browser
pnpm test:coverage:open
```

## CI/CD Integration

### GitHub Actions Workflow

```yaml
name: Testing
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
      - uses: pnpm/action-setup@v2
      - run: pnpm install
      - run: pnpm test:coverage
      - run: pnpm test:integration
      - uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info
```

### Parallel Test Execution

```bash
# Run tests in parallel across packages
pnpm test --parallel

# Run specific test types
pnpm test:unit
pnpm test:integration
pnpm test:contract
```

## Performance Optimization

### Test Performance Tips

1. **Use Test Parallelization**: Run tests in parallel when possible
2. **Optimize Database Tests**: Use transactions for rollback instead of full cleanup
3. **Mock External Dependencies**: Avoid real network calls in unit tests
4. **Use Test Doubles**: Replace slow dependencies with fast mocks
5. **Selective Test Running**: Run only affected tests during development

### Example Optimizations

```typescript
// ✅ Fast: Use transaction rollback
await transactionTester.withTransaction(async () => {
	// Test operations - automatically rolled back
})

// ✅ Fast: Mock external services
vi.mock('../external-api', () => ({
	fetchUserData: vi.fn().mockResolvedValue(mockUserData),
}))

// ✅ Fast: Use fake timers
timeController.start()
timeController.advance(1000) // Instant
```

## Documentation Standards

### Test Documentation

- **Describe blocks**: Use clear, descriptive names
- **Test names**: Should read like specifications
- **Comments**: Explain complex setup or assertions
- **Examples**: Provide examples for common patterns

### Example Documentation

```typescript
describe('User Authentication Service', () => {
	describe('when user provides valid credentials', () => {
		it('should return authentication token and user data', async () => {
			// Arrange: Create test user with known credentials
			const user = MockDataFactory.createUser({
				email: 'test@example.com',
				password: 'hashedPassword123',
			})

			// Act: Attempt authentication
			const result = await authService.authenticate({
				email: user.email,
				password: 'password123',
			})

			// Assert: Verify successful authentication
			expect(result.success).toBe(true)
			expect(result.token).toBeDefined()
			expect(result.user.email).toBe(user.email)
		})
	})
})
```

## Migration Guide

### From Jest to Vitest

```typescript
// Jest
import { jest } from '@jest/globals'
jest.mock('../module')

// Vitest
import { vi } from 'vitest'
vi.mock('../module')
```

### From Legacy Testing

1. **Update imports**: Change from Jest to Vitest
2. **Update configuration**: Use Vitest config format
3. **Update mocks**: Use vi instead of jest
4. **Update assertions**: Use Vitest expect API
5. **Update setup**: Use Vitest setup files

## Conclusion

This comprehensive testing guide provides the foundation for robust, maintainable testing in the macro-ai project. By
following these patterns and practices, you can create tests that provide real value, catch bugs early, and enable
confident refactoring.

For specific examples and advanced usage, refer to the test files in the `test-helpers/__tests__/` directory, which
demonstrate all the patterns and utilities described in this guide.
