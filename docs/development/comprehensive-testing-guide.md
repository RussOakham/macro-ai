# Comprehensive Testing Guide

## Table of Contents

1. [Overview](#overview)
2. [Testing Philosophy](#testing-philosophy)
3. [Testing Frameworks & Tools](#testing-frameworks--tools)
4. [Test Types & Strategies](#test-types--strategies)
5. [Test Structure & Organization](#test-structure--organization)
6. [Testing Utilities & Helpers](#testing-utilities--helpers)
7. [Advanced Testing Techniques](#advanced-testing-techniques)
8. [Best Practices](#best-practices)
9. [Common Patterns](#common-patterns)
10. [Troubleshooting](#troubleshooting)

## Overview

This guide provides comprehensive documentation for testing in the macro-ai monorepo. Our testing strategy emphasizes practical,
valuable tests that provide confidence in code quality while maintaining developer productivity.

### Testing Goals

- **Quality Assurance**: Catch bugs before they reach production
- **Documentation**: Tests serve as living documentation of expected behavior
- **Refactoring Safety**: Enable confident refactoring with comprehensive test coverage
- **Developer Experience**: Fast, reliable tests that don't impede development flow

## Testing Philosophy

Our testing approach aligns with the guidelines in `CLAUDE.md`:

### Core Principles

1. **Focus on Value**: Write tests that provide real value, not just coverage numbers
2. **Test Behavior**: Test what the code does, not how it does it
3. **Realistic Scenarios**: Use realistic test data and scenarios
4. **Maintainability**: Tests should be easy to understand and maintain
5. **Fast Feedback**: Tests should run quickly to enable rapid development cycles

### What NOT to Test

- **Autogenerated Code**: API clients, route trees, and other generated files
- **Third-party Libraries**: Assume they are tested by their maintainers
- **Trivial Code**: Simple getters, setters, and pass-through functions
- **React Components**: Use Storybook tests and E2E tests instead of unit tests
- **Configuration Files**: Focus on the logic that uses configuration

## Testing Frameworks & Tools

### Core Testing Stack

- **Vitest**: Primary test runner and assertion library
- **React Testing Library**: For React component testing
- **MSW (Mock Service Worker)**: API mocking and service worker testing
- **Testcontainers**: Real database integration testing
- **Faker.js**: Realistic test data generation

### Additional Tools

- **SuperTest**: HTTP assertion testing for APIs
- **Vitest Mock Extended**: Enhanced mocking capabilities
- **Node Mocks HTTP**: HTTP request/response mocking
- **Coverage Tools**: v8 provider with comprehensive reporting

## Test Types & Strategies

### 1. Unit Tests

**Purpose**: Test individual functions and modules in isolation

**When to Use**:

- Business logic functions
- Utility functions
- Service layer logic
- Data access layer methods

**Example**:

```typescript
import { describe, it, expect } from 'vitest'
import { calculateTotal } from '../utils/calculations'

describe('calculateTotal', () => {
	it('should calculate total with tax', () => {
		const result = calculateTotal(100, 0.1)
		expect(result).toBe(110)
	})
})
```

### 2. Integration Tests

**Purpose**: Test how multiple components work together

**When to Use**:

- API endpoints with database operations
- Service interactions
- External API integrations
- Complex business workflows

**Example**:

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest'
import {
	setupDatabaseIntegration,
	cleanupGlobalResources,
} from '../test-helpers'
import request from 'supertest'

describe('User API Integration', () => {
	let dbContext
	let app

	beforeAll(async () => {
		dbContext = await setupDatabaseIntegration()
		app = createApp(dbContext.db)
	})

	afterAll(async () => {
		await cleanupGlobalResources()
	})

	it('should create and retrieve user', async () => {
		const userData = {
			email: 'test@example.com',
			firstName: 'John',
			lastName: 'Doe',
		}

		const createResponse = await request(app)
			.post('/api/users')
			.send(userData)
			.expect(201)

		const userId = createResponse.body.data.id

		const getResponse = await request(app)
			.get(`/api/users/${userId}`)
			.expect(200)

		expect(getResponse.body.data.email).toBe(userData.email)
	})
})
```

### 3. Contract Tests

**Purpose**: Verify API contracts between services

**When to Use**:

- API consumer/provider interactions
- Microservice communication
- External API integrations
- Breaking change detection

**Example**:

```typescript
import { ContractBuilder, ContractTester } from '../test-helpers'

describe('User API Contract', () => {
	it('should validate user creation contract', async () => {
		const contract = new ContractBuilder()
			.post('/api/users', 'Create user')
			.withRequestBody({
				email: 'test@example.com',
				firstName: 'John',
				lastName: 'Doe',
			})
			.willRespondWith(201)
			.withResponseBody({
				id: 'user-123',
				email: 'test@example.com',
				firstName: 'John',
				lastName: 'Doe',
			})
			.done()
			.build({
				name: 'user-api',
				version: '1.0.0',
				consumer: 'client-ui',
				provider: 'express-api',
			})

		const contractTester = new ContractTester()
		contractTester.registerContract('user-api', contract)

		const result = await contractTester.testConsumer(
			'user-api',
			async (mockServerUrl) => {
				// Test consumer making requests to mock server
				const response = await fetch(`${mockServerUrl}/api/users`, {
					method: 'POST',
					body: JSON.stringify(userData),
				})
				expect(response.status).toBe(201)
			},
		)

		expect(result).toBe(true)
	})
})
```

### 4. Performance Tests

**Purpose**: Verify performance characteristics and identify bottlenecks

**When to Use**:

- Critical path operations
- Database query performance
- API response times
- Memory usage validation

**Example**:

```typescript
import { PerformanceTester } from '../test-helpers'

describe('Database Performance', () => {
	it('should perform user queries within acceptable time', async () => {
		const performanceTester = new PerformanceTester()

		const results = await performanceTester.runPerformanceTest(
			'userQuery',
			async () => await getUserById('user-123'),
			{
				iterations: 100,
				warmup: 10,
				measureMemory: true,
			},
		)

		expect(results.summary.avgDuration).toBeLessThan(50) // 50ms max
		expect(results.summary.throughput).toBeGreaterThan(20) // 20 ops/sec min
	})
})
```

## Test Structure & Organization

### File Organization

```text
src/
├── features/
│   └── auth/
│       ├── __tests__/
│       │   ├── auth.controller.test.ts
│       │   ├── auth.service.test.ts
│       │   └── auth.routes.integration.test.ts
│       ├── auth.controller.ts
│       ├── auth.service.ts
│       └── auth.routes.ts
└── utils/
    └── test-helpers/
        ├── __tests__/
        │   ├── database-integration.example.test.ts
        │   ├── advanced-mocking.example.test.ts
        │   └── pact-contract.example.test.ts
        ├── database-integration.ts
        ├── advanced-mocking.ts
        ├── pact-contract-testing.ts
        └── index.ts
```

### Naming Conventions

- **Unit Tests**: `*.test.ts` - Tests for individual functions/modules
- **Integration Tests**: `*.integration.test.ts` - Tests for component interactions
- **Example Tests**: `*.example.test.ts` - Demonstration and documentation tests
- **Mock Files**: `*.mock.ts` - Mock implementations and factories

### Test Structure Pattern

```typescript
describe('Feature/Component Name', () => {
	// Setup and teardown
	beforeAll(async () => {
		// Global setup
	})

	beforeEach(() => {
		// Test-specific setup
	})

	afterEach(() => {
		// Test-specific cleanup
	})

	afterAll(async () => {
		// Global cleanup
	})

	// Group related tests
	describe('Specific Functionality', () => {
		it('should handle normal case', () => {
			// Test implementation
		})

		it('should handle edge case', () => {
			// Test implementation
		})

		it('should handle error case', () => {
			// Test implementation
		})
	})
})
```

## Testing Utilities & Helpers

### Database Integration Testing

```typescript
import {
	setupDatabaseIntegration,
	cleanupGlobalResources,
} from './test-helpers'

// Setup real database for integration tests
const dbContext = await setupDatabaseIntegration({
	useTestcontainers: true,
	runMigrations: true,
	seedTestData: true,
})

// Use in tests
const user = await dbContext.db.insert(usersTable).values(userData).returning()
```

### Time-Based Testing

```typescript
import { TimeController } from './test-helpers'

const timeController = new TimeController({
	useFakeTimers: true,
	autoAdvance: false,
})

// Control time in tests
timeController.start()
setTimeout(operation, 5000)
timeController.advance(5000) // Fast-forward 5 seconds
timeController.stop()
```

### Error Simulation

```typescript
import { ErrorSimulator } from './test-helpers'

const errorSimulator = new ErrorSimulator({
	probability: 0.1,
	errorTypes: ['network', 'database', 'validation'],
})

// Test error handling
const resilientFunction = errorSimulator.wrapWithErrorSimulation(
	async () => ({ success: true }),
	'network',
)
```

### Mock Data Generation

```typescript
import { MockDataFactory, createMockData } from './test-helpers'

// Generate realistic test data
const user = MockDataFactory.createUser({
	email: 'test@example.com',
})

const users = MockDataFactory.createArray(
	() => MockDataFactory.createUser(),
	10,
	{ department: 'Engineering' },
)

// Using convenience functions
const chat = createMockData.chat({ title: 'Test Chat' })
const apiResponse = createMockData.apiResponse(user)
```

## Advanced Testing Techniques

### 1. Parameterized Testing

```typescript
describe.each([
	{ input: 'valid@email.com', expected: true },
	{ input: 'invalid-email', expected: false },
	{ input: '', expected: false },
])('Email validation with $input', ({ input, expected }) => {
	it(`should return ${expected}`, () => {
		expect(validateEmail(input)).toBe(expected)
	})
})
```

### 2. Snapshot Testing

```typescript
it('should match API response snapshot', async () => {
	const response = await request(app).get('/api/users/123').expect(200)

	expect(response.body).toMatchSnapshot()
})
```

### 3. Property-Based Testing

```typescript
import { fc } from 'fast-check'

it('should validate all email formats', () => {
	fc.assert(
		fc.property(fc.emailAddress(), (email) => {
			expect(validateEmail(email)).toBe(true)
		}),
	)
})
```

### 4. Mutation Testing

```typescript
it('should handle concurrent modifications', async () => {
	const user = await createUser()

	const updates = await Promise.allSettled([
		updateUser(user.id, { firstName: 'John' }),
		updateUser(user.id, { lastName: 'Doe' }),
		updateUser(user.id, { email: 'new@example.com' }),
	])

	expect(updates.every((u) => u.status === 'fulfilled')).toBe(true)
})
```

## Best Practices

### 1. Test Data Management

```typescript
// ✅ Good: Use factories for consistent test data
const user = MockDataFactory.createUser({
	email: 'test@example.com',
})

// ❌ Avoid: Hardcoded test data scattered throughout tests
const user = {
	id: 'user-123',
	email: 'test@example.com',
	firstName: 'John',
	// ... many fields
}
```

### 2. Assertion Quality

```typescript
// ✅ Good: Specific, meaningful assertions
expect(response.status).toBe(201)
expect(response.body.data.email).toBe(userData.email)
expect(response.body.data.id).toMatch(/^[0-9a-f-]{36}$/)

// ❌ Avoid: Vague or overly broad assertions
expect(response).toBeTruthy()
expect(response.body).toBeDefined()
```

### 3. Error Testing

```typescript
// ✅ Good: Test specific error scenarios
it('should handle invalid email format', async () => {
	await expect(createUser({ email: 'invalid' })).rejects.toThrow(
		'Invalid email format',
	)
})

// ✅ Good: Test error recovery
it('should retry on network failure', async () => {
	const mockFetch = vi
		.fn()
		.mockRejectedValueOnce(new Error('Network error'))
		.mockResolvedValueOnce({ ok: true, json: () => ({ success: true }) })

	const result = await resilientApiCall()
	expect(mockFetch).toHaveBeenCalledTimes(2)
	expect(result.success).toBe(true)
})
```

### 4. Test Isolation

```typescript
// ✅ Good: Each test is independent
beforeEach(async () => {
	await cleanDatabase()
	await seedTestData()
})

// ✅ Good: Use transactions for database tests
await transactionTester.withTransaction(async (client) => {
	// Test operations that will be rolled back
	await createUser(userData)
	// Test assertions
})
```

### 5. Async Testing

```typescript
// ✅ Good: Proper async/await usage
it('should handle async operations', async () => {
	const result = await asyncOperation()
	expect(result).toBeDefined()
})

// ✅ Good: Test timing with fake timers
it('should handle delayed operations', async () => {
	timeController.start()

	const promise = delayedOperation(5000)
	timeController.advance(5000)

	const result = await promise
	expect(result).toBe('completed')

	timeController.stop()
})
```

## Common Patterns

### 1. Database Testing Pattern

```typescript
describe('User Data Access', () => {
	let dbContext: DatabaseTestContext

	beforeAll(async () => {
		dbContext = await setupDatabaseIntegration()
	})

	afterAll(async () => {
		await cleanupGlobalResources()
	})

	beforeEach(async () => {
		await dbContext.seedTestData()
	})

	it('should create user', async () => {
		const userData = MockDataFactory.createUser()
		const [user] = await dbContext.db
			.insert(usersTable)
			.values(userData)
			.returning()

		expect(user.email).toBe(userData.email)
	})
})
```

### 2. API Testing Pattern

```typescript
describe('User API', () => {
	let app: Express
	let dbContext: DatabaseTestContext

	beforeAll(async () => {
		dbContext = await setupDatabaseIntegration()
		app = createServer(dbContext.db)
	})

	afterAll(async () => {
		await cleanupGlobalResources()
	})

	it('should create user via API', async () => {
		const userData = {
			email: 'test@example.com',
			firstName: 'John',
			lastName: 'Doe',
		}

		const response = await request(app)
			.post('/api/users')
			.send(userData)
			.expect(201)

		expect(response.body.data.email).toBe(userData.email)
	})
})
```

### 3. Service Mocking Pattern

```typescript
describe('User Service', () => {
	let userService: UserService
	let mockDb: MockedDatabase

	beforeEach(() => {
		mockDb = createMockDatabase()
		userService = new UserService(mockDb)
	})

	it('should handle database errors gracefully', async () => {
		mockDb.insert.mockRejectedValue(new Error('Database connection failed'))

		await expect(userService.createUser(userData)).rejects.toThrow(
			'Failed to create user',
		)
	})
})
```

### 4. Time-Dependent Testing Pattern

```typescript
describe('Scheduled Operations', () => {
	let timeController: TimeController

	beforeEach(() => {
		timeController = new TimeController()
		timeController.start()
	})

	afterEach(() => {
		timeController.stop()
	})

	it('should execute scheduled task', async () => {
		const task = vi.fn()
		scheduleTask(task, 60000) // 1 minute

		// Fast-forward time
		timeController.advance(60000)
		await timeController.waitForTimers()

		expect(task).toHaveBeenCalledOnce()
	})
})
```

### 5. Error Recovery Testing Pattern

```typescript
describe('Resilient Service', () => {
	let errorSimulator: ErrorSimulator

	beforeEach(() => {
		errorSimulator = new ErrorSimulator({
			probability: 0.3,
			errorTypes: ['network', 'timeout'],
		})
		errorSimulator.start()
	})

	afterEach(() => {
		errorSimulator.stop()
	})

	it('should retry on transient failures', async () => {
		const service = new ResilientService()

		// Test multiple times to trigger error scenarios
		for (let i = 0; i < 10; i++) {
			const result = await service.performOperation()
			expect(result.success).toBe(true)
		}
	})
})
```

## Test Configuration

### Vitest Configuration

```typescript
// vitest.config.ts
export default defineConfig({
	test: {
		environment: 'node',
		globals: true,
		setupFiles: ['./vitest.setup.ts'],
		coverage: {
			provider: 'v8',
			reporter: ['text', 'json', 'html', 'lcov'],
			thresholds: {
				global: {
					statements: 80,
					branches: 75,
					functions: 80,
					lines: 80,
				},
			},
		},
	},
})
```

### Test Setup

```typescript
// vitest.setup.ts
import { beforeAll, afterAll } from 'vitest'
import { setupMSW } from './test-helpers/msw-setup'

beforeAll(async () => {
	// Global test setup
	await setupMSW()
})

afterAll(async () => {
	// Global test cleanup
	await cleanupGlobalResources()
})
```

## Troubleshooting

### Common Issues

#### 1. Tests Timing Out

**Symptoms**: Tests hang or timeout
**Solutions**:

- Use fake timers for time-dependent tests
- Ensure proper cleanup in afterEach/afterAll
- Check for unresolved promises
- Add explicit timeouts to long-running tests

```typescript
it('should complete within time limit', async () => {
	// Add explicit timeout
}, 10000) // 10 second timeout
```

#### 2. Database Connection Issues

**Symptoms**: "Connection pool exhausted" or "Too many connections"
**Solutions**:

- Properly close database connections
- Use connection pooling
- Clean up test containers

```typescript
afterAll(async () => {
	await dbContext.cleanup()
	await cleanupGlobalResources()
})
```

#### 3. Flaky Tests

**Symptoms**: Tests pass/fail inconsistently
**Solutions**:

- Use deterministic test data
- Control time with fake timers
- Ensure proper test isolation
- Avoid race conditions

```typescript
// ✅ Good: Deterministic
faker.seed(12345)
const user = MockDataFactory.createUser()

// ✅ Good: Controlled timing
timeController.start()
timeController.advance(1000)
```

#### 4. Memory Leaks in Tests

**Symptoms**: Tests slow down over time, memory usage increases
**Solutions**:

- Clean up event listeners
- Stop timers and intervals
- Close database connections
- Clear mocks and spies

```typescript
afterEach(() => {
	vi.clearAllMocks()
	timeController.stop()
	errorSimulator.stop()
})
```

## Coverage Guidelines

### Coverage Targets

- **Statements**: 80% minimum
- **Branches**: 75% minimum
- **Functions**: 80% minimum
- **Lines**: 80% minimum

### Coverage Exclusions

- Autogenerated files (`**/*.gen.ts`)
- Configuration files (`**/*.config.*`)
- Type definition files (`**/*.d.ts`)
- Test files themselves (`**/*.test.ts`, `**/*.spec.ts`)
- Main entry points (`**/main.tsx`, `**/main.ts`)

### Coverage Analysis

```bash
# Generate coverage report
pnpm test:coverage

# Analyze coverage gaps
pnpm test:coverage:analyze

# Open coverage report in browser
pnpm test:coverage:open
```

## CI/CD Integration

### GitHub Actions Workflow

```yaml
name: Testing
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
      - uses: pnpm/action-setup@v2
      - run: pnpm install
      - run: pnpm test:coverage
      - run: pnpm test:integration
      - uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info
```

### Parallel Test Execution

```bash
# Run tests in parallel across packages
pnpm test --parallel

# Run specific test types
pnpm test:unit
pnpm test:integration
pnpm test:contract
```

## Performance Optimization

### Test Performance Tips

1. **Use Test Parallelization**: Run tests in parallel when possible
2. **Optimize Database Tests**: Use transactions for rollback instead of full cleanup
3. **Mock External Dependencies**: Avoid real network calls in unit tests
4. **Use Test Doubles**: Replace slow dependencies with fast mocks
5. **Selective Test Running**: Run only affected tests during development

### Example Optimizations

```typescript
// ✅ Fast: Use transaction rollback
await transactionTester.withTransaction(async () => {
	// Test operations - automatically rolled back
})

// ✅ Fast: Mock external services
vi.mock('../external-api', () => ({
	fetchUserData: vi.fn().mockResolvedValue(mockUserData),
}))

// ✅ Fast: Use fake timers
timeController.start()
timeController.advance(1000) // Instant
```

## Documentation Standards

### Test Documentation

- **Describe blocks**: Use clear, descriptive names
- **Test names**: Should read like specifications
- **Comments**: Explain complex setup or assertions
- **Examples**: Provide examples for common patterns

### Example Documentation

```typescript
describe('User Authentication Service', () => {
	describe('when user provides valid credentials', () => {
		it('should return authentication token and user data', async () => {
			// Arrange: Create test user with known credentials
			const user = MockDataFactory.createUser({
				email: 'test@example.com',
				password: 'hashedPassword123',
			})

			// Act: Attempt authentication
			const result = await authService.authenticate({
				email: user.email,
				password: 'password123',
			})

			// Assert: Verify successful authentication
			expect(result.success).toBe(true)
			expect(result.token).toBeDefined()
			expect(result.user.email).toBe(user.email)
		})
	})
})
```

## Migration Guide

### From Jest to Vitest

```typescript
// Jest
import { jest } from '@jest/globals'
jest.mock('../module')

// Vitest
import { vi } from 'vitest'
vi.mock('../module')
```

### From Legacy Testing

1. **Update imports**: Change from Jest to Vitest
2. **Update configuration**: Use Vitest config format
3. **Update mocks**: Use vi instead of jest
4. **Update assertions**: Use Vitest expect API
5. **Update setup**: Use Vitest setup files

## Conclusion

This comprehensive testing guide provides the foundation for robust, maintainable testing in the macro-ai project. By
following these patterns and practices, you can create tests that provide real value, catch bugs early, and enable
confident refactoring.

For specific examples and advanced usage, refer to the test files in the `test-helpers/__tests__/` directory, which
demonstrate all the patterns and utilities described in this guide.
