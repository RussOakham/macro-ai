name: Deploy Staging Environment

on:
  pull_request:
    types: [ opened, reopened, synchronize ]
    branches: [ develop ]
    paths:
    - 'infrastructure/**'
    - 'apps/express-api/**'
    - 'apps/client-ui/**'
    - 'packages/macro-ai-api-client/**'
    - 'packages/ui-library/**'
    - '.github/workflows/deploy-staging.yml'
    - '.github/workflows/reusable-*.yml'
  workflow_dispatch:
    inputs:
      force-deploy:
        description: 'Force deployment even if no changes detected'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  actions: read
  pull-requests: write
  issues: write
  id-token: write

env:
  AWS_REGION: us-east-1
  NODE_VERSION: '20.19.4'
  PNPM_VERSION: '10.14.0'
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  CDK_DEFAULT_ACCOUNT: ${{ secrets.AWS_ACCOUNT_ID }}
  CDK_DEFAULT_REGION: us-east-1
  CUSTOM_DOMAIN_NAME: ${{ vars.CUSTOM_DOMAIN_NAME }}
  HOSTED_ZONE_ID: ${{ vars.HOSTED_ZONE_ID }}

jobs:
  # Change detection using reusable workflow
  change-detection:
    name: Detect Changes
    uses: ./.github/workflows/reusable-change-detection.yml
    with:
      base-ref: ${{ github.event.pull_request.base.sha || github.event.before || 'HEAD~1' }}
      head-ref: ${{ github.event.pull_request.head.sha || github.sha }}

  # Build Express API Docker image
  build-express-api:
    name: Build Docker Image for ECS
    runs-on: ubuntu-latest
    needs: [ change-detection ]
    if: |
      needs.change-detection.outputs.has-backend-changes == 'true' ||
      needs.change-detection.outputs.has-infrastructure-changes == 'true' ||
      github.event.inputs.force-deploy == 'true'

    permissions:
      id-token: write
      contents: read
      actions: write

    outputs:
      image-uri: ${{ steps.build.outputs.image-uri }}
      image-tag: ${{ steps.build.outputs.image-tag }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install pnpm
      uses: pnpm/action-setup@v4
      with:
        version: ${{ env.PNPM_VERSION }}

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}

    - name: Cache pnpm dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.pnpm-store
          node_modules
        key: pnpm-${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}
        restore-keys: |
          pnpm-${{ runner.os }}-

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        role-session-name: github-actions-build-docker-staging
        aws-region: ${{ env.AWS_REGION }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Generate image tag
      id: image-tag
      run: |
        IMAGE_TAG="staging-${{ github.sha }}"
        echo "image-tag=${IMAGE_TAG}" >> "$GITHUB_OUTPUT"
        echo "Generated image tag: ${IMAGE_TAG}"

    - name: Prepare build context (no secrets)
      id: prepare-build
      run: |
        echo "ðŸ” Preparing Docker build context without secrets..."
        echo "âœ… Build context prepared - secrets will be injected at runtime via ECS"

    - name: Build and push Docker image
      id: build
      run: |
        ECR_REPOSITORY="macro-ai-staging-express-api"
        IMAGE_TAG="${{ steps.image-tag.outputs.image-tag }}"
        ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"

        if [[ -z "${ECR_REGISTRY}" ]]; then
          echo "âš ï¸ ECR registry output is empty, using fallback from AWS account ID"
          ECR_REGISTRY="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
        fi

        IMAGE_URI="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"

        echo "ðŸ³ Building Docker image..."
        echo "Repository: ${ECR_REPOSITORY}"
        echo "Tag: ${IMAGE_TAG}"
        echo "Registry: ${ECR_REGISTRY}"
        echo "URI: ${IMAGE_URI}"

        # Create ECR repository if it doesn't exist
        aws ecr describe-repositories --repository-names "${ECR_REPOSITORY}" >/dev/null 2>&1 || {
          echo "ðŸ“¦ Creating ECR repository: ${ECR_REPOSITORY}"
          aws ecr create-repository \
            --repository-name "${ECR_REPOSITORY}" \
            --image-scanning-configuration scanOnPush=true \
            --encryption-configuration encryptionType=AES256
        }

        # Build without injecting secrets (use ECS runtime secrets)
        docker buildx build \
          --file apps/express-api/Dockerfile.distroless \
          --target ecs-runner \
          --platform linux/amd64 \
          --cache-from type=gha \
          --cache-to type=gha,mode=max \
          --tag "${IMAGE_URI}" \
          --push \
          .

        echo "âœ… Image built and pushed successfully!"
        echo "image-uri=${IMAGE_URI}" >> "$GITHUB_OUTPUT"
        echo "image-tag=${IMAGE_TAG}" >> "$GITHUB_OUTPUT"

    - name: Save image URI to artifact
      env:
        IMAGE_URI: ${{ steps.build.outputs.image-uri }}
        IMAGE_TAG: ${{ steps.build.outputs.image-tag }}
      run: |
        echo "${IMAGE_URI}" > image-uri.txt
        echo "${IMAGE_TAG}" > image-tag.txt

    - name: Upload Docker image artifacts
      uses: actions/upload-artifact@v4
      with:
        name: docker-image-info
        path: |
          image-uri.txt
          image-tag.txt
        retention-days: 1

  # Deploy backend using reusable workflow
  deploy-backend:
    name: Deploy Backend
    needs: [ change-detection, build-express-api ]
    uses: ./.github/workflows/reusable-deploy-backend.yml
    with:
      environment-name: staging
      deployment-type: staging
      deployment-scale: preview
      branch-name: ${{ github.event.pull_request.head.ref }}
      image-uri: ${{ needs.build-express-api.outputs.image-uri }}
      custom-domain-name: ${{ vars.CUSTOM_DOMAIN_NAME }}
      hosted-zone-id: ${{ vars.HOSTED_ZONE_ID }}
      should-deploy: ${{ needs.change-detection.outputs.has-backend-changes == 'true' || needs.change-detection.outputs.has-infrastructure-changes == 'true' || github.event.inputs.force-deploy == 'true' }}
    secrets:
      API_KEY: ${{ secrets.API_KEY }}
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
      AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
      SERVER_PORT: ${{ secrets.SERVER_PORT }}
      RATE_LIMIT_WINDOW_MS: ${{ secrets.RATE_LIMIT_WINDOW_MS }}
      RATE_LIMIT_MAX_REQUESTS: ${{ secrets.RATE_LIMIT_MAX_REQUESTS }}
      AUTH_RATE_LIMIT_WINDOW_MS: ${{ secrets.AUTH_RATE_LIMIT_WINDOW_MS }}
      AUTH_RATE_LIMIT_MAX_REQUESTS: ${{ secrets.AUTH_RATE_LIMIT_MAX_REQUESTS }}
      API_RATE_LIMIT_WINDOW_MS: ${{ secrets.API_RATE_LIMIT_WINDOW_MS }}
      API_RATE_LIMIT_MAX_REQUESTS: ${{ secrets.API_RATE_LIMIT_MAX_REQUESTS }}
      COST_ALERT_EMAILS: ${{ secrets.COST_ALERT_EMAILS }}

  # Deploy frontend using reusable workflow
  deploy-frontend:
    name: Deploy Frontend
    uses: ./.github/workflows/reusable-deploy-frontend.yml
    with:
      environment-name: staging
      deployment-type: staging
      branch-name: develop
      backend-url: ${{ format('https://api-staging.{0}', vars.CUSTOM_DOMAIN_NAME) }}
      custom-domain-name: ${{ vars.CUSTOM_DOMAIN_NAME }}
      hosted-zone-id: ${{ vars.HOSTED_ZONE_ID }}
      should-deploy: ${{ needs.change-detection.outputs.has-frontend-changes == 'true' || github.event.inputs.force-deploy == 'true' }}
    secrets:
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
      AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
      API_KEY: ${{ secrets.API_KEY }}
    needs: [ change-detection ]

  # Schedule automatic teardown at 6 PM
  schedule-teardown:
    name: Schedule Automatic Teardown
    runs-on: ubuntu-latest
    needs: [ deploy-backend, deploy-frontend ]
    if: always() && (needs.deploy-backend.result == 'success' || needs.deploy-frontend.result == 'success')

    steps:
    - name: Schedule teardown
      run: |
        echo "ðŸ•• Staging environment will be automatically torn down at 6 PM"
        echo "This helps control costs for the personal project"
        echo "To prevent teardown, run the workflow with 'force-deploy: true'"

  # Summary job
  deployment-summary:
    name: Staging Deployment Summary
    runs-on: ubuntu-latest
    needs: [ change-detection, deploy-backend, deploy-frontend, schedule-teardown ]
    if: always()

    steps:
    - name: Generate deployment summary
      run: |
        echo "ðŸš€ Staging deployment completed!"
        echo "Change Detection: ${{ needs.change-detection.outputs.deployment-scope }}"
        echo "Backend: ${{ needs.deploy-backend.result == 'success' && 'Deployed' || 'Skipped' }}"
        echo "Frontend: ${{ needs.deploy-frontend.result == 'success' && 'Deployed' || 'Skipped' }}"
        echo ""
        echo "ðŸ•• Automatic teardown scheduled for 6 PM"
        echo "To prevent teardown, run the workflow with 'force-deploy: true'"

    - name: Create deployment summary comment
      if: github.event_name == 'push'
      uses: actions/github-script@v7
      with:
        script: |
          const frontendDeployed = '${{ needs.deploy-frontend.result }}' === 'success';
          const backendDeployed = '${{ needs.deploy-backend.result }}' === 'success';
          const deploymentScope = '${{ needs.change-detection.outputs.deployment-scope }}';

          // Get deployment details using predictable URLs
          const customDomain = '${{ vars.CUSTOM_DOMAIN_NAME }}';
          const appUrl = frontendDeployed ? `https://staging.${customDomain}` : null;
          const appId = frontendDeployed ? '${{ needs.deploy-frontend.outputs.app-id }}' : null;
          const backendUrl = backendDeployed ? `https://api-staging.${customDomain}` : null;
          const backendStack = backendDeployed ? '${{ needs.deploy-backend.outputs.stack-name }}' : null;

          const comment = `## ðŸš€ Staging Environment Deployed Successfully!

          ### ðŸŒ Staging URLs
          - **Frontend**: ${appUrl ? `[${appUrl}](${appUrl})` : 'Not deployed'}
          - **Backend API**: ${backendUrl || 'Not deployed'}

          ### ðŸ“‹ Deployment Details
          - **Environment**: \`staging\`
          - **Deployment Scope**: \`${deploymentScope}\`
          - **Amplify App ID**: \`${appId || 'N/A'}\`
          - **Branch**: \`develop\`
          - **Backend Status**: ${backendDeployed ? 'âœ… Deployed' : 'â­ï¸ Skipped (no changes)'}
          - **Frontend Status**: ${frontendDeployed ? 'âœ… Deployed' : 'â­ï¸ Skipped (no changes)'}

          ### ðŸ”— Quick Links
          ${appId ? `- [AWS Amplify Console](https://console.aws.amazon.com/amplify/home?region=us-east-1#/${appId})` : ''}
          ${backendStack ? `- [Backend Stack](https://console.aws.amazon.com/cloudformation/home?region=us-east-1#/stacks/stackinfo?stackId=${backendStack})` : ''}

          ### ðŸŽ¯ Change Detection Results
          - **Backend Changes**: ${{ needs.change-detection.outputs.has-backend-changes == 'true' && 'âœ…' || 'âŒ' }}
          - **Frontend Changes**: ${{ needs.change-detection.outputs.has-frontend-changes == 'true' && 'âœ…' || 'âŒ' }}
          - **Infrastructure Changes**: ${{ needs.change-detection.outputs.has-infrastructure-changes == 'true' && 'âœ…' || 'âŒ' }}

          ### ðŸ•• Cost Management
          - **Automatic Teardown**: Scheduled for 6 PM today
          - **To Prevent Teardown**: Run workflow with \`force-deploy: true\`
          - **Manual Teardown**: Use the \`teardown-staging.yml\` workflow

          ---
          *Staging environment provides a persistent testing environment with automatic cost controls.*`;

          // Find the latest commit and comment on it
          const { data: commits } = await github.rest.repos.listCommits({
            owner: context.repo.owner,
            repo: context.repo.repo,
            sha: 'develop',
            per_page: 1
          });

          if (commits.length > 0) {
            await github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: commits[0].sha,
              body: comment
            });
          }
