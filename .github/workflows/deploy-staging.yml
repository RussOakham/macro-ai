name: Deploy Staging Environment

on:
  pull_request:
    types: [opened, reopened, synchronize]
    branches: [develop]
    paths:
      - 'infrastructure/**'
      - 'apps/express-api/**'
      - 'apps/client-ui/**'
      - 'packages/macro-ai-api-client/**'
      - 'packages/ui-library/**'
      - '.github/workflows/deploy-staging.yml'
      - '.github/workflows/reusable-*.yml'
  workflow_dispatch:
    inputs:
      force-deploy:
        description: 'Force deployment even if no changes detected'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  actions: read
  pull-requests: write
  issues: write
  id-token: write

env:
  AWS_REGION: us-east-1
  NODE_VERSION: '20.19.4'
  PNPM_VERSION: '10.14.0'
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  CDK_DEFAULT_ACCOUNT: ${{ secrets.AWS_ACCOUNT_ID }}
  CDK_DEFAULT_REGION: us-east-1
  CUSTOM_DOMAIN_NAME: ${{ vars.CUSTOM_DOMAIN_NAME }}
  HOSTED_ZONE_ID: ${{ vars.HOSTED_ZONE_ID }}

jobs:
  # Force deployment (change detection disabled for testing)
  change-detection:
    name: Force Deployment (Change Detection Disabled)
    runs-on: ubuntu-latest
    outputs:
      has-backend-changes: true
      has-frontend-changes: true
      has-infrastructure-changes: true
      has-workflow-changes: true
      deployment-scope: both
      changed-files: '[]'
    steps:
      - name: Force deployment for testing
        run: |
          echo "ðŸš€ Change detection disabled - forcing deployment of all components for testing"
          echo "This ensures the workflow runs fully every time while we test the deployment fix"

  # Build Express API Docker image
  build-express-api:
    name: Build Docker Image for ECS
    runs-on: ubuntu-latest
    needs: [change-detection]
    if: |
      needs.change-detection.outputs.has-backend-changes == 'true' || needs.change-detection.outputs.has-infrastructure-changes == 'true'

    permissions:
      id-token: write
      contents: read
      actions: write

    outputs:
      image-uri: ${{ steps.build.outputs.image-uri }}
      image-tag: ${{ steps.build.outputs.image-tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Cache pnpm dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.pnpm-store
            node_modules
          key: pnpm-${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            pnpm-${{ runner.os }}-

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: github-actions-build-docker-staging
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Generate image tag
        id: image-tag
        run: |
          IMAGE_TAG="staging-${{ github.sha }}"
          echo "image-tag=${IMAGE_TAG}" >> "$GITHUB_OUTPUT"
          echo "Generated image tag: ${IMAGE_TAG}"

      - name: Generate environment file from Parameter Store
        id: generate-env
        run: |
          echo "ðŸ” Fetching environment variables from AWS Parameter Store..."

          # For staging deployments, use staging environment parameters
          ENV_NAME="staging"
          PARAM_PATH="/macro-ai/${ENV_NAME}"
          ENV_FILE="apps/express-api/.env.docker"

          echo "ðŸŒ Environment: ${ENV_NAME}"
          echo "ðŸ“¥ Fetching from: ${PARAM_PATH}"

          # Create the environment file using our script
          chmod +x apps/express-api/scripts/generate-env-from-parameter-store.sh

          # Set APP_ENV for the new programmatic approach
          APP_ENV="staging"

          # Pass only APP_ENV and AWS_REGION to the script
          # All other environment variables are sourced from Parameter Store
          ENV_FILE="${ENV_FILE}" \
          AWS_REGION="us-east-1" \
          APP_ENV="${APP_ENV}" \
          ./apps/express-api/scripts/generate-env-from-parameter-store.sh

          echo "âœ… Environment file generated from ${ENV_NAME} environment"
          echo "env-file=${ENV_FILE}" >> "$GITHUB_OUTPUT"

      - name: Build and push Docker image
        id: build
        run: |
          ECR_REPOSITORY="macro-ai-staging-express-api"
          IMAGE_TAG="${{ steps.image-tag.outputs.image-tag }}"
          ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"

          if [[ -z "${ECR_REGISTRY}" ]]; then
            echo "âš ï¸ ECR registry output is empty, using fallback from AWS account ID"
            ECR_REGISTRY="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          fi

          IMAGE_URI="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"

          echo "ðŸ³ Building Docker image..."
          echo "Repository: ${ECR_REPOSITORY}"
          echo "Tag: ${IMAGE_TAG}"
          echo "Registry: ${ECR_REGISTRY}"
          echo "URI: ${IMAGE_URI}"

          # Create ECR repository if it doesn't exist
          aws ecr describe-repositories --repository-names "${ECR_REPOSITORY}" >/dev/null 2>&1 || {
            echo "ðŸ“¦ Creating ECR repository: ${ECR_REPOSITORY}"
            aws ecr create-repository \
              --repository-name "${ECR_REPOSITORY}" \
              --image-scanning-configuration scanOnPush=true \
              --encryption-configuration encryptionType=AES256
          }

          # Build with environment file using BuildKit
          docker buildx build \
            --file apps/express-api/Dockerfile.distroless \
            --target ecs-runner \
            --platform linux/amd64 \
            --build-arg ENV_FILE="${{ steps.generate-env.outputs.env-file }}" \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            --tag "${IMAGE_URI}" \
            --push \
            .

          echo "âœ… Image built and pushed successfully!"
          echo "image-uri=${IMAGE_URI}" >> "$GITHUB_OUTPUT"
          echo "image-tag=${IMAGE_TAG}" >> "$GITHUB_OUTPUT"

      - name: Save image URI to artifact
        env:
          IMAGE_URI: ${{ steps.build.outputs.image-uri }}
          IMAGE_TAG: ${{ steps.build.outputs.image-tag }}
        run: |
          echo "${IMAGE_URI}" > image-uri.txt
          echo "${IMAGE_TAG}" > image-tag.txt

      - name: Upload Docker image artifacts
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-info
          path: |
            image-uri.txt
            image-tag.txt
          retention-days: 1

      - name: Cleanup environment file
        if: always()
        run: |
          ENV_FILE="${{ steps.generate-env.outputs.env-file }}"
          if [[ -f "${ENV_FILE}" ]]; then
            rm -f "${ENV_FILE}"
            echo "ðŸ§¹ Cleaned up: ${ENV_FILE}"
          fi

  # Deploy backend using reusable workflow
  deploy-backend:
    name: Deploy Backend
    needs: [change-detection, build-express-api]
    uses: ./.github/workflows/reusable-deploy-backend.yml
    with:
      environment-name: staging
      deployment-type: staging
      deployment-scale: preview
      branch-name: ${{ github.event.pull_request.head.ref }}
      image-uri: ${{ needs.build-express-api.outputs.image-uri }}
      custom-domain-name: ${{ vars.CUSTOM_DOMAIN_NAME }}
      hosted-zone-id: ${{ vars.HOSTED_ZONE_ID }}
      should-deploy: ${{ needs.change-detection.outputs.has-backend-changes == 'true' || needs.change-detection.outputs.has-infrastructure-changes == 'true' }}
    secrets:
      # Only pass AWS credentials for CDK deployment
      # All other environment variables are sourced from Parameter Store
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
      AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}

  # Deploy frontend using reusable workflow
  deploy-frontend:
    name: Deploy Frontend
    uses: ./.github/workflows/reusable-deploy-frontend.yml
    with:
      environment-name: staging
      deployment-type: staging
      branch-name: develop
      backend-url: ${{ format('https://api-staging.{0}', vars.CUSTOM_DOMAIN_NAME) }}
      custom-domain-name: ${{ vars.CUSTOM_DOMAIN_NAME }}
      hosted-zone-id: ${{ vars.HOSTED_ZONE_ID }}
      should-deploy: ${{ needs.change-detection.outputs.has-frontend-changes == 'true' || github.event.inputs.force-deploy == 'true' }}
    secrets:
      # Only pass AWS credentials for CDK deployment
      # All other environment variables are sourced from Parameter Store
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
      AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
    needs: [change-detection]

  # Schedule automatic teardown at 6 PM
  schedule-teardown:
    name: Schedule Automatic Teardown
    runs-on: ubuntu-latest
    needs: [deploy-backend, deploy-frontend]
    if: always() && (needs.deploy-backend.result == 'success' || needs.deploy-frontend.result == 'success')

    steps:
      - name: Schedule teardown
        run: |
          echo "ðŸ•• Staging environment will be automatically torn down at 6 PM"
          echo "This helps control costs for the personal project"
          echo "To prevent teardown, run the workflow with 'force-deploy: true'"

  # Summary job
  deployment-summary:
    name: Staging Deployment Summary
    runs-on: ubuntu-latest
    needs:
      [change-detection, deploy-backend, deploy-frontend, schedule-teardown]
    if: always()

    steps:
      - name: Generate deployment summary
        run: |
          echo "ðŸš€ Staging deployment completed!"
          echo "Change Detection: ${{ needs.change-detection.outputs.deployment-scope }}"
          echo "Backend: ${{ needs.deploy-backend.result == 'success' && 'Deployed' || 'Skipped' }}"
          echo "Frontend: ${{ needs.deploy-frontend.result == 'success' && 'Deployed' || 'Skipped' }}"
          echo ""
          echo "ðŸ•• Automatic teardown scheduled for 6 PM"
          echo "To prevent teardown, run the workflow with 'force-deploy: true'"

      - name: Create deployment summary comment
        if: github.event_name == 'push'
        uses: actions/github-script@v7
        with:
          script: |
            const frontendDeployed = '${{ needs.deploy-frontend.result }}' === 'success';
            const backendDeployed = '${{ needs.deploy-backend.result }}' === 'success';
            const deploymentScope = '${{ needs.change-detection.outputs.deployment-scope }}';

            // Get deployment details using predictable URLs
            const customDomain = '${{ vars.CUSTOM_DOMAIN_NAME }}';
            const appUrl = frontendDeployed ? `https://staging.${customDomain}` : null;
            const appId = frontendDeployed ? '${{ needs.deploy-frontend.outputs.app-id }}' : null;
            const backendUrl = backendDeployed ? `https://api-staging.${customDomain}` : null;
            const backendStack = backendDeployed ? '${{ needs.deploy-backend.outputs.stack-name }}' : null;

            const comment = `## ðŸš€ Staging Environment Deployed Successfully!

            ### ðŸŒ Staging URLs
            - **Frontend**: ${appUrl ? `[${appUrl}](${appUrl})` : 'Not deployed'}
            - **Backend API**: ${backendUrl || 'Not deployed'}

            ### ðŸ“‹ Deployment Details
            - **Environment**: \`staging\`
            - **Deployment Scope**: \`${deploymentScope}\`
            - **Amplify App ID**: \`${appId || 'N/A'}\`
            - **Branch**: \`develop\`
            - **Backend Status**: ${backendDeployed ? 'âœ… Deployed' : 'â­ï¸ Skipped (no changes)'}
            - **Frontend Status**: ${frontendDeployed ? 'âœ… Deployed' : 'â­ï¸ Skipped (no changes)'}

            ### ðŸ”— Quick Links
            ${appId ? `- [AWS Amplify Console](https://console.aws.amazon.com/amplify/home?region=us-east-1#/${appId})` : ''}
            ${backendStack ? `- [Backend Stack](https://console.aws.amazon.com/cloudformation/home?region=us-east-1#/stacks/stackinfo?stackId=${backendStack})` : ''}

            ### ðŸŽ¯ Change Detection Results
            - **Backend Changes**: ${{ needs.change-detection.outputs.has-backend-changes == 'true' && 'âœ…' || 'âŒ' }}
            - **Frontend Changes**: ${{ needs.change-detection.outputs.has-frontend-changes == 'true' && 'âœ…' || 'âŒ' }}
            - **Infrastructure Changes**: ${{ needs.change-detection.outputs.has-infrastructure-changes == 'true' && 'âœ…' || 'âŒ' }}

            ### ðŸ•• Cost Management
            - **Automatic Teardown**: Scheduled for 6 PM today
            - **To Prevent Teardown**: Run workflow with \`force-deploy: true\`
            - **Manual Teardown**: Use the \`teardown-staging.yml\` workflow

            ---
            *Staging environment provides a persistent testing environment with automatic cost controls.*`;

            // Find the latest commit and comment on it
            const { data: commits } = await github.rest.repos.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: 'develop',
              per_page: 1
            });

            if (commits.length > 0) {
              await github.rest.repos.createCommitComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                commit_sha: commits[0].sha,
                body: comment
              });
            }
