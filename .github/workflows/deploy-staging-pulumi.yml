name: Deploy Staging Environment (Pulumi)

on:
  push:
    branches: [develop]
    paths:
      - 'infrastructure/**'
      - 'apps/express-api/**'
      - 'apps/client-ui/**'
      - 'packages/macro-ai-api-client/**'
      - 'packages/ui-library/**'
      - '.github/workflows/deploy-staging-pulumi.yml'
      - '.github/workflows/reusable-*.yml'
  workflow_dispatch:
    inputs:
      force-deploy:
        description: 'Force deployment even if no changes detected'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  actions: read
  pull-requests: write
  issues: write
  id-token: write

env:
  AWS_REGION: us-east-1
  NODE_VERSION: '20.19.4'
  PNPM_VERSION: '10.14.0'
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  CUSTOM_DOMAIN_NAME: ${{ vars.CUSTOM_DOMAIN_NAME }}
  HOSTED_ZONE_ID: ${{ vars.HOSTED_ZONE_ID }}

jobs:
  # Change detection using reusable workflow
  change-detection:
    name: Detect Changes
    uses: ./.github/workflows/reusable-change-detection.yml
    with:
      base-ref: ${{ github.event.before || 'HEAD~1' }}
      head-ref: ${{ github.sha }}

  # Build Express API Docker image
  build-express-api:
    name: Build Docker Image for ECS
    runs-on: ubuntu-latest
    needs: [change-detection]
    if: |
      needs.change-detection.outputs.has-backend-changes == 'true' ||
      needs.change-detection.outputs.has-infrastructure-changes == 'true' ||
      github.event.inputs.force-deploy == 'true'

    permissions:
      id-token: write
      contents: read
      actions: write

    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Cache pnpm dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.pnpm-store
            node_modules
          key: pnpm-${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            pnpm-${{ runner.os }}-

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: github-actions-build-docker-staging
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Generate image tag
        id: image-tag
        run: |
          IMAGE_TAG="staging-${{ github.sha }}"
          echo "image-tag=${IMAGE_TAG}" >> "$GITHUB_OUTPUT"
          echo "Generated image tag: ${IMAGE_TAG}"

      - name: Prepare build context (no secrets)
        id: prepare-build
        run: |
          echo "üîç Preparing Docker build context without secrets..."
          echo "‚úÖ Build context prepared - secrets will be injected at runtime via ECS"

      - name: Build and push Docker image
        id: build
        run: |
          ECR_REPOSITORY="macro-ai-staging-express-api"
          IMAGE_TAG="${{ steps.image-tag.outputs.image-tag }}"
          ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"

          if [[ -z "${ECR_REGISTRY}" ]]; then
            echo "‚ö†Ô∏è ECR registry output is empty, using fallback from AWS account ID"
            ECR_REGISTRY="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          fi

          IMAGE_URI="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"

          echo "üê≥ Building Docker image..."
          echo "Repository: ${ECR_REPOSITORY}"
          echo "Tag: ${IMAGE_TAG}"
          echo "Registry: ${ECR_REGISTRY}"
          echo "URI: ${IMAGE_URI}"

          # Create ECR repository if it doesn't exist
          aws ecr describe-repositories --repository-names "${ECR_REPOSITORY}" >/dev/null 2>&1 || {
            echo "üì¶ Creating ECR repository: ${ECR_REPOSITORY}"
            aws ecr create-repository \
              --repository-name "${ECR_REPOSITORY}" \
              --image-scanning-configuration scanOnPush=true \
              --encryption-configuration encryptionType=AES256
          }

          # Build without injecting secrets (use ECS runtime secrets)
          docker buildx build \
            --file apps/express-api/Dockerfile.distroless \
            --target ecs-runner \
            --platform linux/amd64 \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            --tag "${IMAGE_URI}" \
            --push \
            .

          echo "‚úÖ Image built and pushed successfully!"
          # Save image URI to a file to avoid secret detection
          echo "${IMAGE_URI}" > image-uri.txt
          # Set image tag output only (image URI will come from artifact)
          echo "image-tag=${IMAGE_TAG}" >> "$GITHUB_OUTPUT"

      - name: Upload Docker image info as artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-info
          path: |
            image-uri.txt
          retention-days: 1
        if: always()

  # Deploy backend using Pulumi
  # Get image URI from artifact (artifact-only approach)
  get-image-uri:
    name: Get Image URI from Artifact
    runs-on: ubuntu-latest
    needs: [build-express-api]
    outputs:
      image-uri: ${{ steps.image-uri.outputs.image-uri }}
    steps:
      - name: Download Docker image info artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image-info
          path: ./

      - name: Read image URI from artifact file
        id: image-uri
        run: |
          if [ -f "image-uri.txt" ]; then
            IMAGE_URI=$(cat image-uri.txt)
            echo "‚úÖ Image URI from artifact file: ${IMAGE_URI}"
            
            # Validate IMAGE_URI format
            if [[ ! "${IMAGE_URI}" =~ ^[0-9]+\.dkr\.ecr\..+\.amazonaws\.com/.+:.+ ]]; then
              echo "‚ùå Invalid IMAGE_URI format: ${IMAGE_URI}"
              exit 1
            fi
            
            # Mark image-uri as SAFE to bypass GitHub Actions secret detection
            echo "image-uri<<SAFE>>=${IMAGE_URI}" >> "$GITHUB_OUTPUT"
          else
            echo "‚ùå Error: image-uri.txt not found in artifact"
            ls -la ./
            exit 1
          fi

  deploy-backend:
    name: Deploy Backend (Pulumi)
    uses: ./.github/workflows/reusable-deploy-backend-pulumi.yml
    with:
      environment-name: staging
      deployment-type: staging
      branch-name: develop
      image-uri: ${{ needs.get-image-uri.outputs.image-uri }}
      custom-domain-name: ${{ vars.CUSTOM_DOMAIN_NAME }}
      hosted-zone-id: ${{ vars.HOSTED_ZONE_ID }}
      should-deploy: ${{ needs.change-detection.outputs.has-backend-changes == 'true' || needs.change-detection.outputs.has-infrastructure-changes == 'true' || github.event.inputs.force-deploy == 'true' }}
    secrets:
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
      AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
      PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
      DOPPLER_TOKEN_STAGING: ${{ secrets.DOPPLER_TOKEN_STAGING }}
      DOPPLER_TOKEN_DEV: ${{ secrets.DOPPLER_TOKEN_DEV }}
      DOPPLER_TOKEN_PROD: ${{ secrets.DOPPLER_TOKEN_PROD }}
    needs: [change-detection, get-image-uri]

  # Deploy frontend using reusable workflow
  deploy-frontend:
    name: Deploy Frontend
    uses: ./.github/workflows/reusable-deploy-frontend.yml
    with:
      environment-name: staging
      deployment-type: staging
      branch-name: develop
      backend-url: ${{ format('https://api-staging.{0}', vars.CUSTOM_DOMAIN_NAME) }}
      custom-domain-name: ${{ vars.CUSTOM_DOMAIN_NAME }}
      hosted-zone-id: ${{ vars.HOSTED_ZONE_ID }}
      should-deploy: ${{ needs.change-detection.outputs.has-frontend-changes == 'true' || github.event.inputs.force-deploy == 'true' }}
    secrets:
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
      AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
      API_KEY: ${{ secrets.API_KEY }}
    needs: [change-detection]

  # Schedule automatic teardown at 6 PM
  schedule-teardown:
    name: Schedule Automatic Teardown
    runs-on: ubuntu-latest
    needs: [deploy-backend, deploy-frontend]
    if: always() && (needs.deploy-backend.result == 'success' || needs.deploy-frontend.result == 'success')

    steps:
      - name: Schedule teardown
        run: |
          echo "üïï Staging environment will be automatically torn down at 6 PM"
          echo "This helps control costs for the personal project"
          echo "To prevent teardown, run the workflow with 'force-deploy: true'"

  # Summary job
  deployment-summary:
    name: Staging Deployment Summary (Pulumi)
    runs-on: ubuntu-latest
    needs:
      [change-detection, deploy-backend, deploy-frontend, schedule-teardown]
    if: always()

    steps:
      - name: Generate deployment summary
        run: |
          echo "üöÄ Staging deployment completed with Pulumi!"
          echo "Change Detection: ${{ needs.change-detection.outputs.deployment-scope }}"
          echo "Backend: ${{ needs.deploy-backend.result == 'success' && 'Deployed' || 'Skipped' }}"
          echo "Frontend: ${{ needs.deploy-frontend.result == 'success' && 'Deployed' || 'Skipped' }}"
          echo ""
          echo "üïï Automatic teardown scheduled for 6 PM"
          echo "To prevent teardown, run the workflow with 'force-deploy: true'"

      - name: Create deployment summary comment
        if: github.event_name == 'push'
        uses: actions/github-script@v7
        with:
          script: |
            const frontendDeployed = '${{ needs.deploy-frontend.result }}' === 'success';
            const backendDeployed = '${{ needs.deploy-backend.result }}' === 'success';
            const deploymentScope = '${{ needs.change-detection.outputs.deployment-scope }}';

            // Get deployment details using predictable URLs
            const customDomain = '${{ vars.CUSTOM_DOMAIN_NAME }}';
            const appUrl = frontendDeployed ? `https://staging.${customDomain}` : null;
            const appId = frontendDeployed ? '${{ needs.deploy-frontend.outputs.app-id }}' : null;
            const backendUrl = backendDeployed ? `https://api-staging.${customDomain}` : null;
            const backendStack = backendDeployed ? '${{ needs.deploy-backend.outputs.stack-name }}' : null;

            const comment = `## üöÄ Staging Environment Deployed Successfully! (Pulumi)

            ### üåê Staging URLs
            - **Frontend**: ${appUrl ? `[${appUrl}](${appUrl})` : 'Not deployed'}
            - **Backend API**: ${backendUrl || 'Not deployed'}

            ### üìã Deployment Details
            - **Environment**: \`staging\`
            - **Infrastructure**: \`Pulumi\` (migrated from CDK)
            - **Deployment Scope**: \`${deploymentScope}\`
            - **Amplify App ID**: \`${appId || 'N/A'}\`
            - **Branch**: \`develop\`
            - **Backend Status**: ${backendDeployed ? '‚úÖ Deployed' : '‚è≠Ô∏è Skipped (no changes)'}
            - **Frontend Status**: ${frontendDeployed ? '‚úÖ Deployed' : '‚è≠Ô∏è Skipped (no changes)'}

            ### üîó Quick Links
            ${appId ? `- [AWS Amplify Console](https://console.aws.amazon.com/amplify/home?region=us-east-1#/${appId})` : ''}
            ${backendStack ? `- [Pulumi Stack](https://app.pulumi.com/orgs/macro-ai/stacks/${backendStack})` : ''}

            ### üéØ Change Detection Results
            - **Backend Changes**: ${{ needs.change-detection.outputs.has-backend-changes == 'true' && '‚úÖ' || '‚ùå' }}
            - **Frontend Changes**: ${{ needs.change-detection.outputs.has-frontend-changes == 'true' && '‚úÖ' || '‚ùå' }}
            - **Infrastructure Changes**: ${{ needs.change-detection.outputs.has-infrastructure-changes == 'true' && '‚úÖ' || '‚ùå' }}

            ### üïï Cost Management
            - **Automatic Teardown**: Scheduled for 6 PM today
            - **To Prevent Teardown**: Run workflow with \`force-deploy: true\`
            - **Manual Teardown**: Use the \`teardown-staging.yml\` workflow

            ---
            *Staging environment now uses Pulumi for infrastructure management with Doppler for secrets.*`;

            // Find the latest commit and comment on it
            const { data: commits } = await github.rest.repos.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: 'develop',
              per_page: 1
            });

            if (commits.length > 0) {
              await github.rest.repos.createCommitComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                commit_sha: commits[0].sha,
                body: comment
              });
            }
