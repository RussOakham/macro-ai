---
name: Deploy PR Preview (Pulumi)

on:
  pull_request:
    types: [ opened, synchronize, closed ]
    branches:
    - main
    - develop

concurrency:
  group: '${{ github.workflow }} @ ${{ github.event.pull_request.head.label || github.event.pull_request.head.ref || github.ref }}'
  cancel-in-progress: true

env:
  AWS_REGION: us-east-1
  NODE_VERSION: '20.19.4'
  PNPM_VERSION: '10.14.0'

jobs:
  deploy-pr-preview:
    name: Deploy PR Preview Infrastructure
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
      pull-requests: write
    outputs:
      api-endpoint: ${{ steps.deploy.outputs.api-endpoint }}
      stack-name: ${{ steps.deploy.outputs.stack-name }}
      should-deploy: ${{ steps.decide-deploy.outputs.should-deploy }}
      has-backend-changes: ${{ steps.change-detection.outputs.has-backend-changes }}
      has-frontend-changes: ${{ steps.change-detection.outputs.has-frontend-changes }}
      has-infrastructure-changes: ${{ steps.change-detection.outputs.has-infrastructure-changes }}
      is-first-deployment: ${{ steps.change-detection.outputs.is-first-deployment }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup pnpm
      uses: pnpm/action-setup@v4
      with:
        version: '10.14.0'

    - name: Detect changes
      id: change-detection
      env:
        BASE_REF: ${{ github.event.pull_request.base.ref }}
        HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        PR_NUMBER: ${{ github.event.number }}
        BRANCH_REF: ${{ github.event.pull_request.head.ref }}
      run: |
        echo "üîç Detecting changes for PR #$PR_NUMBER..."

        # Get base branch (default to develop if not specified)
        BASE_BRANCH="$BASE_REF"
        if [[ -z "$BASE_BRANCH" ]]; then
          BASE_BRANCH="develop"
        fi

        # Get head SHA
        HEAD_REF="$HEAD_SHA"

        echo "Base branch: $BASE_BRANCH"
        echo "Head SHA: $HEAD_REF"

        # Fetch the base branch to compare against
        git fetch origin "$BASE_BRANCH"

        # Check for backend-related changes
        BACKEND_CHANGES=$(git diff --name-only "origin/$BASE_BRANCH...$HEAD_REF" | grep -E '^infrastructure/|^apps/express-api/|^packages/macro-ai-api-client/' || true)
        if [[ -n "$BACKEND_CHANGES" ]]; then
          echo "‚úÖ Backend changes detected"
          echo "has-backend-changes=true" >> "$GITHUB_OUTPUT"
        else
          echo "‚ÑπÔ∏è No backend changes detected"
          echo "has-backend-changes=false" >> "$GITHUB_OUTPUT"
        fi

        # Check for frontend-related changes
        FRONTEND_CHANGES=$(git diff --name-only "origin/$BASE_BRANCH...$HEAD_REF" | grep -E '^apps/client-ui/|^packages/ui-library/' || true)
        if [[ -n "$FRONTEND_CHANGES" ]]; then
          echo "‚úÖ Frontend changes detected"
          echo "has-frontend-changes=true" >> "$GITHUB_OUTPUT"
        else
          echo "‚ÑπÔ∏è No frontend changes detected"
          echo "has-frontend-changes=false" >> "$GITHUB_OUTPUT"
        fi

        # Check for infrastructure-related changes
        INFRASTRUCTURE_CHANGES=$(git diff --name-only "origin/$BASE_BRANCH...$HEAD_REF" | grep -E '^infrastructure/|\.github/workflows/.*\.yml$' || true)
        if [[ -n "$INFRASTRUCTURE_CHANGES" ]]; then
          echo "‚úÖ Infrastructure changes detected"
          echo "has-infrastructure-changes=true" >> "$GITHUB_OUTPUT"
        else
          echo "‚ÑπÔ∏è No infrastructure changes detected"
          echo "has-infrastructure-changes=false" >> "$GITHUB_OUTPUT"
        fi

        # Check if this is the first deployment of this PR environment
        PR_NUMBER="${{ github.event.number }}"
        STACK_NAME="pr-${PR_NUMBER}"
        if pulumi stack select "$STACK_NAME" 2>/dev/null; then
          # Stack exists, this is not the first deployment
          echo "‚ÑπÔ∏è Existing PR environment detected - using selective deployment"
          echo "is-first-deployment=false" >> "$GITHUB_OUTPUT"
        else
          # Stack doesn't exist, this is the first deployment
          echo "üöÄ First deployment of PR environment - deploying both backend and frontend"
          echo "is-first-deployment=true" >> "$GITHUB_OUTPUT"
          # On first deployment, set both to true to ensure complete environment
          echo "has-backend-changes=true" >> "$GITHUB_OUTPUT"
          echo "has-frontend-changes=true" >> "$GITHUB_OUTPUT"
        fi

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20.19.4'

    - name: Cache pnpm dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.pnpm-store
          node_modules
        key: pnpm-${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}
        restore-keys: |
          pnpm-${{ runner.os }}-

    - name: Install Pulumi CLI
      run: |
        curl -fsSL https://get.pulumi.com | sh
        echo "$HOME/.pulumi/bin" >> "$GITHUB_PATH"

    - name: Configure AWS credentials
      if: github.event.action != 'closed'
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        role-session-name: pr-preview-build-docker
        aws-region: ${{ env.AWS_REGION }}

    - name: Log in to Amazon ECR
      if: github.event.action != 'closed'
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and push Docker image
      if: github.event.action != 'closed'
      id: build-image
      env:
        AWS_REGION: ${{ env.AWS_REGION }}
        DOCKER_BUILDKIT: 1
      run: |
        # Build Docker image for PR
        IMAGE_TAG="pr-${{ github.event.number }}-${{ github.run_id }}"
        ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"

        # Build and push to ECR using buildx (automatically uses ECR login)
        docker buildx build \
          --build-arg NODE_ENV=production \
          --build-arg SERVER_PORT=3040 \
          --build-arg APP_ENV=pr-${{ github.event.number }} \
          --target runner \
          --no-cache \
          --platform linux/amd64 \
          --tag "${ECR_REGISTRY}/macro-ai-staging-express-api:${IMAGE_TAG}" \
          --push \
          -f apps/express-api/Dockerfile \
          .

        echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
        echo "‚úÖ Docker image built and pushed: ${IMAGE_TAG}"

    - name: Decide deployment action
      id: decide-deploy
      run: |
        echo "üîç Deciding deployment action..."

        # Check if PR is closed
        if [[ "${{ github.event.action }}" == "closed" ]]; then
          echo "should-deploy=false" >> $GITHUB_OUTPUT
          echo "deployment-action=destroy" >> $GITHUB_OUTPUT
          echo "‚úÖ PR closed - will destroy environment"
          exit 0
        fi

        # Check if any changes require deployment
        HAS_BACKEND="${{ steps.change-detection.outputs.has-backend-changes }}"
        HAS_FRONTEND="${{ steps.change-detection.outputs.has-frontend-changes }}"
        HAS_INFRASTRUCTURE="${{ steps.change-detection.outputs.has-infrastructure-changes }}"

        echo "Backend changes: $HAS_BACKEND"
        echo "Frontend changes: $HAS_FRONTEND"
        echo "Infrastructure changes: $HAS_INFRASTRUCTURE"

        # Deploy if any changes are detected
        if [[ "$HAS_BACKEND" == "true" || "$HAS_FRONTEND" == "true" || "$HAS_INFRASTRUCTURE" == "true" ]]; then
          echo "should-deploy=true" >> $GITHUB_OUTPUT
          echo "deployment-action=deploy" >> $GITHUB_OUTPUT
          echo "‚úÖ Changes detected - will deploy"
        else
          echo "should-deploy=false" >> $GITHUB_OUTPUT
          echo "deployment-action=skip" >> $GITHUB_OUTPUT
          echo "‚è≠Ô∏è No relevant changes - skipping deployment"
        fi

    - name: Install Pulumi CLI
      if: steps.decide-deploy.outputs.should-deploy == 'true' && (steps.change-detection.outputs.has-backend-changes == 'true' || steps.change-detection.outputs.has-infrastructure-changes == 'true' || steps.change-detection.outputs.is-first-deployment == 'true')
      uses: pulumi/actions@v5
      with:
        pulumi-version: latest

    - name: Install Pulumi Dependencies
      if: steps.decide-deploy.outputs.should-deploy == 'true' && (steps.change-detection.outputs.has-backend-changes == 'true' || steps.change-detection.outputs.has-infrastructure-changes == 'true' || steps.change-detection.outputs.is-first-deployment == 'true')
      shell: bash
      run: |
        echo "üì¶ Installing Pulumi project dependencies..."
        cd infrastructure/pulumi
        pnpm install

    - name: Deploy PR Preview Infrastructure
      if: steps.decide-deploy.outputs.should-deploy == 'true' && (steps.change-detection.outputs.has-backend-changes == 'true' || steps.change-detection.outputs.has-infrastructure-changes == 'true' || steps.change-detection.outputs.is-first-deployment == 'true')
      id: deploy
      env:
        PR_NUMBER: ${{ github.event.number }}
        BRANCH_REF: ${{ github.event.pull_request.head.ref }}
        DOPPLER_TOKEN: ${{ secrets.DOPPLER_TOKEN_DEV }}
      run: |
        echo "üöÄ Starting PR Preview deployment..."
        echo "Environment: pr-$PR_NUMBER"
        echo "PR Number: $PR_NUMBER"
        echo "Branch: $BRANCH_REF"
        echo "Image Tag: ${{ steps.build-image.outputs.image-tag }}"

        # Call the reusable workflow via GitHub API or use a different approach
        # For now, we'll use the Pulumi CLI directly
        cd infrastructure/pulumi

        # Set up environment variables
        export PULUMI_ACCESS_TOKEN="${{ secrets.PULUMI_ACCESS_TOKEN }}"
        export AWS_REGION="${{ env.AWS_REGION }}"
        export AWS_ACCOUNT_ID="${{ secrets.AWS_ACCOUNT_ID }}"

        STACK_NAME="pr-${{ github.event.number }}"
        IMAGE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/macro-ai-staging-express-api:${{ steps.build-image.outputs.image-tag }}"

        echo "üîß Setting Pulumi configuration for stack: ${STACK_NAME}"
        pulumi stack select ${STACK_NAME} || pulumi stack init ${STACK_NAME}

        # Set all required configuration
        pulumi config set environmentName "pr-${{ github.event.number }}" --stack "${STACK_NAME}"
        pulumi config set deploymentType "preview" --stack "${STACK_NAME}"
        pulumi config set imageUri "${IMAGE_URI}" --stack "${STACK_NAME}"
        pulumi config set imageTag "${{ steps.build-image.outputs.image-tag }}" --stack "${STACK_NAME}"
        pulumi config set doppler:dopplerToken "${DOPPLER_TOKEN}" --secret --stack "${STACK_NAME}"
        # Doppler config is handled in Pulumi code for PR previews (uses 'dev' config)
        pulumi config set prNumber "${{ github.event.number }}" --stack "${STACK_NAME}"
        pulumi config set branchName "$BRANCH_REF" --stack "${STACK_NAME}"
        pulumi config set customDomainName "macro-ai.russoakham.dev" --stack "${STACK_NAME}"
        pulumi config set hostedZoneId "${{ secrets.ROUTE53_HOSTED_ZONE_ID }}" --stack "${STACK_NAME}"

        echo "üöÄ Deploying infrastructure..."
        pulumi up --yes --stack "${STACK_NAME}"

        # Get outputs
        API_ENDPOINT=$(pulumi stack output apiEndpoint --stack "${STACK_NAME}")
        STACK_NAME_OUTPUT=$(pulumi stack output stackName --stack "${STACK_NAME}" || echo "${STACK_NAME}")

        echo "api-endpoint=${API_ENDPOINT}" >> $GITHUB_OUTPUT
        echo "stack-name=${STACK_NAME_OUTPUT}" >> $GITHUB_OUTPUT

        echo "‚úÖ Backend deployment completed successfully!"
        echo "üåê API Endpoint: ${API_ENDPOINT}"

  deploy-frontend:
    name: Deploy Frontend to Amplify
    runs-on: ubuntu-latest
    needs: deploy-pr-preview
    if: needs.deploy-pr-preview.outputs.should-deploy == 'true' && (needs.deploy-pr-preview.outputs.has-frontend-changes == 'true' || needs.deploy-pr-preview.outputs.is-first-deployment == 'true') && needs.deploy-pr-preview.outputs.api-endpoint != ''
    permissions:
      id-token: write
      contents: read
      pull-requests: write
    outputs:
      app-url: ${{ steps.deploy.outputs.app-url }}
      app-id: ${{ steps.deploy.outputs.app-id }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup pnpm
      uses: pnpm/action-setup@v4
      with:
        version: '${{ env.PNPM_VERSION }}'

    - name: Cache pnpm dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.pnpm-store
          node_modules
        key: pnpm-${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}
        restore-keys: |
          pnpm-${{ runner.os }}-

    - name: Install dependencies
      run: |
        cd apps/client-ui
        pnpm install --frozen-lockfile

    - name: Generate API client package
      env:
        # Minimal environment variables required for swagger generation
        API_KEY: 'placeholder-api-key-for-swagger-generation-32chars'
        NODE_ENV: 'development'
        APP_ENV: 'development'
        SERVER_PORT: '3040'
        AWS_COGNITO_REGION: 'us-east-1'
        AWS_COGNITO_USER_POOL_ID: 'us-east-1_placeholder'
        AWS_COGNITO_USER_POOL_CLIENT_ID: 'placeholder-client-id'
        AWS_COGNITO_REFRESH_TOKEN_EXPIRY: '30'
        COOKIE_DOMAIN: 'localhost'
        COOKIE_ENCRYPTION_KEY: 'placeholder-cookie-encryption-key-32chars'
        REDIS_URL: 'redis://localhost:6379'
        RELATIONAL_DATABASE_URL: 'postgresql://localhost:5432/placeholder'
        OPENAI_API_KEY: 'sk-placeholder-openai-api-key-for-swagger-generation'
        RATE_LIMIT_WINDOW_MS: '900000'
        RATE_LIMIT_MAX_REQUESTS: '100'
        AUTH_RATE_LIMIT_WINDOW_MS: '3600000'
        AUTH_RATE_LIMIT_MAX_REQUESTS: '10'
        API_RATE_LIMIT_WINDOW_MS: '60000'
        API_RATE_LIMIT_MAX_REQUESTS: '60'
        COST_ALERT_EMAILS: 'placeholder-cost-alert-emails'
      run: |
        echo "üîß Generating API client package from OpenAPI specification"

        # Install dependencies for express-api to generate OpenAPI spec
        cd apps/express-api
        pnpm install --frozen-lockfile

        # Generate OpenAPI specification
        echo "üìã Generating OpenAPI specification..."
        pnpm run generate-swagger

        # Build the API client package
        echo "üì¶ Building API client package..."
        cd ../../packages/macro-ai-api-client
        pnpm install --frozen-lockfile
        pnpm run build

        echo "‚úÖ API client package built successfully"

    - name: Generate environment configuration
      id: generate-env-config
      uses: ./.github/actions/generate-frontend-env
      with:
        environment: ${{ github.event.number }}
        pr-number: ${{ github.event.number }}
        build-mode: 'preview'
        # Use Doppler synced secrets instead of hardcoded values
        api-endpoint: ${{ needs.deploy-pr-preview.outputs.api-endpoint }}
        api-key: ${{ secrets.API_KEY }}
        backend-stack-name: 'placeholder'
        resolution-method: 'artifact-based'
        output-file: '.env.preview'
        include-build-metadata: 'true'
        validate-variables: 'true'
        debug: 'false'

    - name: Generate Amplify configuration
      run: |
        cd apps/client-ui

        ENV_NAME="${{ github.event.number }}"
        DEPLOYMENT_TYPE="preview"

        # Set environment variables for configuration generation
        PNPM_VERSION="${{ env.PNPM_VERSION }}"

        # Load environment variables from .env.preview
        TEMP_ENV_FILE=$(mktemp)
        if grep '^[A-Za-z_][A-Za-z0-9_]*=' ".env.preview" > "${TEMP_ENV_FILE}"; then
          echo "Found environment variables in .env.preview"
        else
          echo "No environment variables found in .env.preview"
          touch "$TEMP_ENV_FILE"
        fi

        # Export variables safely
        if [[ -s "$TEMP_ENV_FILE" ]]; then
          while IFS= read -r line; do
            [[ -z "$line" || "${line:0:1}" == "#" ]] && continue
            if [[ "$line" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
              key="${line%%=*}"
              value="${line#*=}"
              if [[ "$value" == \"*\" && "$value" == *\" ]]; then
                value="${value:1:-1}"
              elif [[ "$value" == \'*\' && "$value" == *\' ]]; then
                value="${value:1:-1}"
              fi
              printf -v "$key" '%s' "$value"
              export "$key"
            fi
          done < "$TEMP_ENV_FILE"
          echo "‚úÖ Loaded $(wc -l < "$TEMP_ENV_FILE") environment variables"
        fi

        # Clean up temporary file
        rm -f "$TEMP_ENV_FILE"

        # Generate amplify.yml configuration
        printf 'version: 1\napplications:\n  - appRoot: apps/client-ui\n    frontend:\n      phases:\n        preBuild:\n          commands:\n            - echo "Installing dependencies..."\n            - npm install -g pnpm@%s\n            - pnpm install --frozen-lockfile\n        build:\n          commands:\n            - echo "Building React application..."\n            - pnpm run build\n      artifacts:\n        baseDirectory: dist\n        files:\n          - "**/*"\n      cache:\n        paths:\n          - node_modules/**/*\n          - .pnpm-store/**/*\n' "${PNPM_VERSION}" > amplify.yml

        echo "‚úÖ Generated amplify.yml configuration"

    - name: Build React application
      run: |
        cd apps/client-ui

        # Load environment variables from .env.preview
        TEMP_ENV_FILE=$(mktemp)
        if grep '^[A-Za-z_][A-Za-z0-9_]*=' ".env.preview" > "${TEMP_ENV_FILE}"; then
          echo "Found environment variables in .env.preview"
        else
          echo "No environment variables found in .env.preview"
          touch "$TEMP_ENV_FILE"
        fi

        if [[ -s "$TEMP_ENV_FILE" ]]; then
          while IFS= read -r line; do
            [[ -z "$line" || "${line:0:1}" == "#" ]] && continue
            if [[ "$line" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
              key="${line%%=*}"
              value="${line#*=}"
              if [[ "$value" == \"*\" && "$value" == *\" ]]; then
                value="${value:1:-1}"
              elif [[ "$value" == \'*\' && "$value" == *\' ]]; then
                value="${value:1:-1}"
              fi
              printf -v "$key" '%s' "$value"
              export "$key"
            fi
          done < "$TEMP_ENV_FILE"
          echo "‚úÖ Loaded environment variables for build"
        fi

        # Clean up temporary file
        rm -f "$TEMP_ENV_FILE"

        # Build the application
        echo "üî® Building React application..."
        pnpm run build

        echo "‚úÖ Build completed successfully"

        # Verify build output
        if [[ -d "dist" && -f "dist/index.html" ]]; then
          echo "‚úÖ Build artifacts verified"
          echo "üìä Build size: $(du -sh dist)"
        else
          echo "‚ùå Build verification failed"
          exit 1
        fi

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}
        role-session-name: pr-preview-amplify-deployment

    - name: Generate Frontend Environment Variables
      id: generate-env
      run: |
        echo "Generating frontend environment variables..."
        # Determine VITE_API_URL based on backend-url input
        VITE_API_URL="${{ needs.deploy-pr-preview.outputs.api-endpoint }}"
        echo "VITE_API_URL=$VITE_API_URL" >> $GITHUB_ENV
        echo "VITE_API_KEY=${{ secrets.VITE_API_KEY }}" >> $GITHUB_ENV
        echo "Generated VITE_API_URL: $VITE_API_URL"
        echo "Generated VITE_API_KEY: (masked)"

    - name: Deploy to Amplify
      id: deploy
      env:
        PR_NUMBER: ${{ github.event.number }}
      run: |
        echo "Deploying frontend to Amplify..."
        # Use a single Amplify app for all PR previews (following Amplify's intended GitHub integration)
        APP_NAME="macro-ai-pr-previews"
        BRANCH_NAME="pr-${PR_NUMBER}"

        # Check if the PR previews app exists, create it if not
        APP_ID=$(aws amplify list-apps --query "apps[?name=='$APP_NAME'].appId" --output text)

        if [ -z "$APP_ID" ]; then
          echo "Creating Amplify app for PR previews without GitHub integration..."
          CREATE_APP_OUTPUT=$(aws amplify create-app \
            --name "$APP_NAME" \
            --description "Frontend for PR preview environments" \
            --platform WEB \
            --region "${AWS_REGION}")
          APP_ID=$(echo "$CREATE_APP_OUTPUT" | jq -r '.app.appId')
          echo "Created Amplify app with ID: $APP_ID"
        else
          echo "Using existing Amplify app with ID: $APP_ID"
        fi

        # Create or update the branch for this PR
        echo "Setting up branch for PR preview..."

        # Check if branch exists
        BRANCH_EXISTS=$(aws amplify list-branches \
          --app-id "$APP_ID" \
          --region "${AWS_REGION}" \
          --query "branches[?branchName=='$BRANCH_NAME'].branchName" \
          --output text 2>/dev/null || echo "")

        if [[ -z "$BRANCH_EXISTS" || "$BRANCH_EXISTS" == "None" ]]; then
          echo "Creating new branch: $BRANCH_NAME"
          aws amplify create-branch \
            --app-id "$APP_ID" \
            --branch-name "$BRANCH_NAME" \
            --description "Branch for PR preview environment" \
            --stage "DEVELOPMENT" \
            --environment-variables "VITE_API_URL=$VITE_API_URL,VITE_API_KEY=$VITE_API_KEY" \
            --region "${AWS_REGION}"
        else
          echo "Updating existing branch: $BRANCH_NAME"
          aws amplify update-branch \
            --app-id "$APP_ID" \
            --branch-name "$BRANCH_NAME" \
            --stage "DEVELOPMENT" \
            --environment-variables "VITE_API_URL=$VITE_API_URL,VITE_API_KEY=$VITE_API_KEY" \
            --region "${AWS_REGION}"
        fi
        echo "Branch setup completed: $BRANCH_NAME"

        # Deploy the application
        echo "üöÄ Starting deployment..."

        # Ensure build artifacts exist and zip them
        cd apps/client-ui
        if [[ -d "dist" ]]; then
          (cd dist && zip -qr ../build.zip .)
        else
          echo "‚ùå Build artifacts not found in apps/client-ui/dist"
          exit 1
        fi

        # Request a deployment
        DEPLOY_JSON=$(aws amplify create-deployment \
          --app-id "$APP_ID" \
          --branch-name "$BRANCH_NAME" \
          --region "${AWS_REGION}")
        JOB_ID=$(echo "$DEPLOY_JSON" | jq -r '.jobId')
        UPLOAD_URL=$(echo "$DEPLOY_JSON" | jq -r '.zipUploadUrl')

        if [[ -z "$JOB_ID" || -z "$UPLOAD_URL" || "$JOB_ID" == "null" || "$UPLOAD_URL" == "null" ]]; then
          echo "‚ùå Failed to create deployment or retrieve upload URL"
          exit 1
        fi

        echo "üìã Deployment job ID: ${JOB_ID}"
        echo "‚¨ÜÔ∏è Uploading build.zip to pre-signed URL"
        curl -sS -X PUT -H "Content-Type: application/zip" --upload-file build.zip "$UPLOAD_URL"

        # Start the deployment
        aws amplify start-deployment \
          --app-id "$APP_ID" \
          --branch-name "$BRANCH_NAME" \
          --job-id "$JOB_ID" \
          --region "${AWS_REGION}"

        # Wait for deployment to complete
        echo "‚è≥ Waiting for deployment to complete..."
        MAX_ATTEMPTS=90; SLEEP=10
        for ((i=1;i<=MAX_ATTEMPTS;i++)); do
          STATUS=$(aws amplify get-job \
            --app-id "$APP_ID" \
            --branch-name "$BRANCH_NAME" \
            --job-id "$JOB_ID" \
            --region "${AWS_REGION}" \
            --query 'job.summary.status' \
            --output text)
          echo "üîé Attempt $i/$MAX_ATTEMPTS: status=${STATUS}"
          if [[ "$STATUS" == "SUCCEED" || "$STATUS" == "FAILED" || "$STATUS" == "CANCELLED" ]]; then
            break
          fi
          sleep $SLEEP
        done

        # Get final deployment status
        JOB_STATUS=$(aws amplify get-job \
          --app-id "$APP_ID" \
          --branch-name "$BRANCH_NAME" \
          --job-id "$JOB_ID" \
          --region "${AWS_REGION}" \
          --query 'job.summary.status' \
          --output text)

        if [[ "$JOB_STATUS" == "SUCCEED" ]]; then
          # Generate app URL
          APP_URL=$(aws amplify get-branch --app-id "$APP_ID" --branch-name "$BRANCH_NAME" --region "${AWS_REGION}" --query "branch.associatedResource.defaultDomain" --output text)

          echo "app-id=${APP_ID}" >> $GITHUB_OUTPUT
          echo "app-url=${APP_URL}" >> $GITHUB_OUTPUT
          echo "‚úÖ Frontend deployment successful!"
          echo "üåê Frontend URL: ${APP_URL}"
        else
          echo "‚ùå Frontend deployment failed with status: ${JOB_STATUS}"
          exit 1
        fi

    - name: Cleanup Amplify Branch on PR Close
      if: github.event.action == 'closed'
      run: |
        echo "PR closed. Cleaning up Amplify branch..."
        # Use the single PR previews app
        APP_NAME="macro-ai-pr-previews"
        PR_NUMBER="${{ github.event.number }}"
        BRANCH_NAME="pr-${PR_NUMBER}"

        # Get the app ID
        APP_ID=$(aws amplify list-apps --query "apps[?name=='$APP_NAME'].appId" --output text)

        if [ -n "$APP_ID" ]; then
          echo "Deleting Amplify branch: $BRANCH_NAME from app: $APP_NAME (ID: $APP_ID)"
          aws amplify delete-branch --app-id "$APP_ID" --branch-name "$BRANCH_NAME" --region "${AWS_REGION}" || echo "Branch $BRANCH_NAME not found, skipping deletion."
          echo "Amplify branch deleted."
        else
          echo "Amplify app $APP_NAME not found, skipping branch deletion."
        fi

    - name: Frontend Deployment Summary
      if: steps.deploy.outputs.app-url
      run: |
        echo "üéâ Complete PR Preview Environment Deployed!"
        echo "üì± Frontend URL: ${{ steps.deploy.outputs.app-url }}"
        echo "üîó Backend API: ${{ needs.deploy-pr-preview.outputs.api-endpoint }}"
        echo "üìù Stack: ${{ needs.deploy-pr-preview.outputs.stack-name }}"
        echo "üî¢ PR: #$PR_NUMBER"
        echo "üåø Branch: $BRANCH_REF"
    - name: Health Check
      if: steps.deploy.outputs.app-url && needs.deploy-pr-preview.outputs.should-deploy == 'true' && needs.deploy-pr-preview.outputs.api-endpoint != '' && needs.deploy-pr-preview.outputs.has-backend-changes == 'true'
      id: health-check
      run: |
        API_ENDPOINT="${{ needs.deploy-pr-preview.outputs.api-endpoint }}"
        echo "üîç Performing health check on: '$API_ENDPOINT'"

        # Wait for the service to be ready
        sleep 30

        # Perform health check
        for i in {1..10}; do
          if curl -f -s "${API_ENDPOINT}/health" > /dev/null 2>&1; then
            echo "‚úÖ Health check passed on attempt ${i}"
            echo "health-status=healthy" >> "$GITHUB_OUTPUT"
            echo "‚úÖ Service is responding at ${API_ENDPOINT}"
            exit 0
          fi
          echo "‚è≥ Health check attempt ${i} failed, retrying..."
          sleep 15
        done

        echo "‚ùå Health check failed after 10 attempts"
        echo "health-status=unhealthy" >> "$GITHUB_OUTPUT"
        exit 1

        - name: Comment PR with deployment info
        if: needs.deploy-pr-preview.outputs.should-deploy == 'true' && needs.deploy-pr-preview.outputs.api-endpoint != '' && needs.deploy-pr-preview.outputs.has-backend-changes == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const apiEndpoint = '${{ needs.deploy-pr-preview.outputs.api-endpoint }}';
            const stackName = '${{ needs.deploy-pr-preview.outputs.stack-name }}';
          const healthStatus = '${{ steps.health-check.outputs.health-status }}';
          const prNumber = '${{ github.event.number }}';
          const branchRef = '${{ github.event.pull_request.head.ref }}';
          const hasBackendChanges = '${{ needs.deploy-pr-preview.outputs.has-backend-changes }}' === 'true';
          const hasFrontendChanges = '${{ needs.deploy-pr-preview.outputs.has-frontend-changes }}' === 'true';

          let healthIcon = '‚ö†Ô∏è';
          let healthMessage = 'Health check in progress...';

          if (healthStatus === 'healthy') {
            healthIcon = '‚úÖ';
            healthMessage = 'Health check passed - service is ready!';
          } else if (healthStatus === 'unhealthy') {
            healthIcon = '‚ùå';
            healthMessage = 'Health check failed - please check the workflow logs';
          }

          const frontendUrl = '${{ needs.deploy-frontend.outputs.app-url }}';

          const body = [
            '## üöÄ PR Preview Environment Deployed',
            '',
            `**${healthIcon} Complete preview environment deployed successfully!**`,
            '',
            '### üåê **Access URLs**',
            `- **Frontend**: ${frontendUrl || 'Deploying...'}`,
            `- **Backend API**: ${apiEndpoint}`,
            `- **Pulumi Stack**: \`${stackName}\``,
            `- **Environment**: Preview for PR #${prNumber}`,
            `- **Branch**: \`${branchRef}\``,
            `- **Health Status**: ${healthMessage}`,
            '',
            '### üîç **Testing Your Changes**',
            '',
            'You can now test your complete application:',
            '1. **Frontend**: Visit the frontend URL above to interact with your changes',
            '2. **Backend API**: Test API endpoints directly at \`' + apiEndpoint + '\`',
            '3. **Health Check**: \`' + apiEndpoint + '/health\`',
            '',
            '### üèóÔ∏è **Infrastructure Details**',
            '- Full ECS Fargate deployment',
            '- Application Load Balancer',
            '- Custom domains (\`pr-' + prNumber + '.api.macro-ai.russoakham.dev\`)',
            '- Doppler secrets integration',
            '- Amplify frontend deployment',
            '',
            '### üßπ Automatic Cleanup',
            '',
            'This environment will be automatically destroyed when you:',
            '- Close this PR',
            '- Merge this PR to main',
            '- Push new commits (environment will be updated)',
            '',
            '**‚ö†Ô∏è Note**: This is a cost-optimized preview environment with reduced resources.'
          ].join('\n');

          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: body
          });

    - name: Comment PR on failure
      if: needs.deploy-pr-preview.outputs.should-deploy == 'true' && failure() && needs.deploy-pr-preview.outputs.has-backend-changes == 'true'
      uses: actions/github-script@v7
      with:
        script: |
          const prNumber = '${{ github.event.number }}';

          const body = [
            '## ‚ùå PR Preview Environment Deployment Failed',
            '',
            '**‚ùå The preview environment could not be deployed.**',
            '',
            'Please check the workflow logs for details. Common issues:',
            '- Docker build failures',
            '- Pulumi deployment errors',
            '- AWS permission issues',
            '- Doppler configuration problems',
            '',
            'The development team has been notified.'
          ].join('\n');

          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: body
          });

    - name: Cleanup on PR close
      if: github.event.action == 'closed'
      id: cleanup
      run: |
        echo "üßπ Cleaning up PR #${{ github.event.number }} environment..."

        # For now, manual cleanup since we're not using Pulumi Review Stacks yet
        # This will be replaced when we configure Review Stacks
        STACK_NAME="pr-${{ github.event.number }}"

        if pulumi stack select ${STACK_NAME} 2>/dev/null; then
          echo "üîç Found stack ${STACK_NAME}, destroying..."
          pulumi destroy --yes --stack "${STACK_NAME}"
          pulumi stack rm ${STACK_NAME} --yes
          echo "‚úÖ Stack ${STACK_NAME} destroyed and removed"
        else
          echo "‚ÑπÔ∏è Stack ${STACK_NAME} not found or already cleaned up"
        fi

        echo "cleanup-status=completed" >> $GITHUB_OUTPUT

    - name: Comment PR on cleanup
      if: github.event.action == 'closed'
      uses: actions/github-script@v7
      with:
        script: |
          const prNumber = '${{ github.event.number }}';

          const body = [
            '## üßπ PR Preview Environment Cleaned Up',
            '',
            '**‚úÖ The preview environment for PR #' + prNumber + ' has been destroyed.**',
            '',
            'The following resources have been cleaned up:',
            '- ECS Fargate service and task definition',
            '- Application Load Balancer and target group',
            '- VPC resources (if not shared)',
            '- CloudWatch log groups',
            '- Route53 records (if applicable)',
            '',
            '**Cost savings**: All preview environment resources have been removed to avoid unnecessary charges.'
          ].join('\n');

          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: body
          });
