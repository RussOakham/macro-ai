name: Deploy PR Preview Environment

on:
  pull_request:
    types: [ opened, reopened, synchronize ]
    branches: [ develop, main ]
    paths:
    - 'infrastructure/**'
    - 'apps/express-api/**'
    - 'apps/client-ui/**'
    - '.github/workflows/deploy-preview.yml'
    - '.github/workflows/deploy-frontend-preview.yml'
    - '.github/actions/check-codeowner/**'
    - '.github/actions/discover-backend/**'
    - '.github/actions/generate-frontend-env/**'

permissions:
  contents: read
  actions: read
  pull-requests: write
  issues: write

env:
  AWS_REGION: us-east-1
  NODE_VERSION: '20'
  PNPM_VERSION: '10.14.0'
  # CDK environment variables
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  CDK_DEFAULT_ACCOUNT: ${{ secrets.AWS_ACCOUNT_ID }}
  CDK_DEFAULT_REGION: us-east-1

jobs:
  # Check if PR author is a code owner and from same repo
  validate-access:
    name: Validate PR Access
    runs-on: ubuntu-latest
    outputs:
      is-owner: ${{ steps.codeowner-check.outputs.is-owner }}
      target-user: ${{ steps.codeowner-check.outputs.target-user }}
      is-same-repo: ${{ steps.repo-check.outputs.is-same-repo }}
      should-deploy: ${{ steps.decision.outputs.should-deploy }}
      env-name: ${{ steps.env-name.outputs.env-name }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.pull_request.head.sha }}

    - name: Check repository ownership
      id: repo-check
      run: |
        if [[ "${{ github.event.pull_request.head.repo.full_name }}" == "${{ github.repository }}" ]]; then
          echo "is-same-repo=true" >> $GITHUB_OUTPUT
          echo "‚úÖ PR from same repository: ${{ github.event.pull_request.head.repo.full_name }}"
        else
          echo "is-same-repo=false" >> $GITHUB_OUTPUT
          echo "‚ùå PR from forked repository: ${{ github.event.pull_request.head.repo.full_name }}"
        fi

    - name: Check code ownership
      id: codeowner-check
      uses: ./.github/actions/check-codeowner
      with:
        mode: 'pr'
        base-ref: ${{ github.event.pull_request.base.ref }}

    - name: Generate environment name
      id: env-name
      run: |
        ENV_NAME="pr-${{ github.event.pull_request.number }}"
        echo "env-name=${ENV_NAME}" >> $GITHUB_OUTPUT
        echo "Environment name: ${ENV_NAME}"

    - name: Make deployment decision
      id: decision
      run: |
        IS_SAME_REPO="${{ steps.repo-check.outputs.is-same-repo }}"
        IS_OWNER="${{ steps.codeowner-check.outputs.is-owner }}"

        if [[ "${IS_SAME_REPO}" == "true" && "${IS_OWNER}" == "true" ]]; then
          echo "should-deploy=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Deployment approved: same-repo PR by code owner ${{ steps.codeowner-check.outputs.target-user }}"
        else
          echo "should-deploy=false" >> $GITHUB_OUTPUT
          echo "‚ùå Deployment blocked:"
          echo "  - Same repo: ${IS_SAME_REPO}"
          echo "  - Code owner: ${IS_OWNER}"
          echo "  - User: ${{ steps.codeowner-check.outputs.target-user }}"
        fi

  # Build Lambda package for deployment
  build-lambda:
    name: Build Lambda Package
    runs-on: ubuntu-latest
    needs: [ validate-access, check-backend-changes ]
    if: needs.validate-access.outputs.should-deploy == 'true' && needs.check-backend-changes.outputs.has-backend-changes == 'true'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install pnpm
      uses: pnpm/action-setup@v3
      with:
        version: ${{ env.PNPM_VERSION }}

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'pnpm'
        cache-dependency-path: 'pnpm-lock.yaml'

    - name: Build Lambda package
      run: |
        cd apps/express-api
        pnpm install --frozen-lockfile
        pnpm build:lambda
        pnpm bundle:lambda
        pnpm package:lambda

    - name: Upload Lambda package
      uses: actions/upload-artifact@v4
      with:
        name: lambda-package-${{ needs.validate-access.outputs.env-name }}
        path: apps/express-api/dist/lambda.zip
        retention-days: 7

  # Deploy Backend Preview Environment (Backend stack and API Gateway)
  deploy-backend-preview:
    name: Deploy Backend Preview
    runs-on: ubuntu-latest
    needs: [ validate-access, build-lambda, check-backend-changes ]
    if: needs.validate-access.outputs.should-deploy == 'true' && needs.check-backend-changes.outputs.has-backend-changes == 'true'
    environment: development

    permissions:
      id-token: write
      contents: read
      pull-requests: write
      issues: write

    outputs:
      api-endpoint: ${{ steps.outputs.outputs.api-endpoint }}
      stack-name: ${{ steps.stack-info.outputs.stack-name }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install pnpm
      uses: pnpm/action-setup@v3
      with:
        version: ${{ env.PNPM_VERSION }}

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'pnpm'
        cache-dependency-path: 'pnpm-lock.yaml'

    - name: Install AWS CDK CLI globally
      run: pnpm add -g aws-cdk@2

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Download Lambda package
      uses: actions/download-artifact@v4
      with:
        name: lambda-package-${{ needs.validate-access.outputs.env-name }}
        path: apps/express-api/dist/

    - name: Generate stack information
      id: stack-info
      run: |
        ENV_NAME="${{ needs.validate-access.outputs.env-name }}"
        # Capitalize first letter for stack name (pr-123 -> Pr-123)
        STACK_NAME="MacroAi$(echo "${ENV_NAME}" | sed 's/^./\U&/')Stack"
        echo "stack-name=${STACK_NAME}" >> $GITHUB_OUTPUT
        echo "Stack name: ${STACK_NAME}"

    - name: Deploy infrastructure
      run: |
        cd infrastructure
        pnpm install --frozen-lockfile
        pnpm build

        echo "üöÄ Deploying ephemeral environment: ${{ needs.validate-access.outputs.env-name }}"
        echo "üì¶ Stack: ${{ steps.stack-info.outputs.stack-name }}"
        echo "üë§ Requested by: ${{ needs.validate-access.outputs.target-user }}"

        # Make deploy script executable and run it
        chmod +x scripts/deploy.sh
        ./scripts/deploy.sh
      env:
        CDK_DEPLOY_ENV: ${{ needs.validate-access.outputs.env-name }}
        CDK_DEPLOY_SCALE: 'hobby'
        AWS_REGION: ${{ env.AWS_REGION }}
        AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
        NODE_ENV: 'production'

    - name: Get deployment outputs
      id: outputs
      run: |
        STACK_NAME="${{ steps.stack-info.outputs.stack-name }}"

        # Get API endpoint from CloudFormation outputs
        API_ENDPOINT=$(aws cloudformation describe-stacks \
          --stack-name "${STACK_NAME}" \
          --query "Stacks[0].Outputs[?OutputKey=='ApiEndpoint'].OutputValue" \
          --output text 2>/dev/null || echo "")

        if [[ -n "${API_ENDPOINT}" ]]; then
          # Normalize to ensure single /api suffix (no duplication)
          API_BASE="${API_ENDPOINT%/}"
          if [[ "$API_BASE" != */api ]]; then
            API_BASE="${API_BASE}/api"
          fi
          echo "api-endpoint=${API_BASE}" >> $GITHUB_OUTPUT
          echo "‚úÖ API endpoint: ${API_BASE}"
        else
          echo "‚ö†Ô∏è Could not retrieve API endpoint"
        fi

    - name: Health check
      id: health-check
      run: |
        API_ENDPOINT="${{ steps.outputs.outputs.api-endpoint }}"

        if [[ -n "${API_ENDPOINT}" ]]; then
          HEALTH_URL="${API_ENDPOINT%/}/health"
          echo "üîç Testing health endpoint: ${HEALTH_URL}"

          # Wait a moment for deployment to stabilize
          sleep 10

          # Test health endpoint with retries
          for i in {1..3}; do
            HEALTH_RESPONSE=$(curl -s -w "%{http_code}" "${HEALTH_URL}" 2>/dev/null || echo "000")
            if [[ "$HEALTH_RESPONSE" == *"200" ]]; then
              echo "health-status=healthy" >> $GITHUB_OUTPUT
              echo "‚úÖ Health check passed (attempt $i)"
              break
            else
              echo "‚ö†Ô∏è Health check failed (attempt $i): $HEALTH_RESPONSE"
              if [[ $i -eq 3 ]]; then
                echo "health-status=unhealthy" >> $GITHUB_OUTPUT
              fi
              sleep 5
            fi
          done
        else
          echo "health-status=unknown" >> $GITHUB_OUTPUT
          echo "‚ö†Ô∏è Cannot perform health check - no API endpoint"
        fi

    - name: Save backend info artifact
      if: always()
      run: |
        mkdir -p backend-info
        jq -n \
          --arg env "${{ needs.validate-access.outputs.env-name }}" \
          --arg stack "${{ steps.stack-info.outputs.stack-name }}" \
          --arg api "${{ steps.outputs.outputs.api-endpoint }}" \
          --arg health "${{ steps.health-check.outputs.health-status }}" \
          '{environment:$env, stack_name:$stack, api_endpoint:$api, health_status:$health}' \
          > backend-info/backend-info.json

    - name: Upload backend info artifact
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: backend-info-${{ needs.validate-access.outputs.env-name }}
        path: backend-info/backend-info.json
        retention-days: 7
        if-no-files-found: ignore

  # Handle blocked deployments (forked PRs or non-code-owners)
  explain-blocked:
    name: Explain Blocked Deployment
    runs-on: ubuntu-latest
    needs: validate-access
    if: needs.validate-access.outputs.should-deploy == 'false'

    permissions:
      pull-requests: write

    steps:
    - name: Comment on blocked PR
      uses: actions/github-script@v7
      with:
        script: |
          const isSameRepo = '${{ needs.validate-access.outputs.is-same-repo }}' === 'true';
          const isOwner = '${{ needs.validate-access.outputs.is-owner }}' === 'true';
          const targetUser = '${{ needs.validate-access.outputs.target-user }}';

          let comment = `## üö´ Preview Environment Deployment Blocked\n\n`;

          if (!isSameRepo) {
            comment += `### üîí Forked Repository\n`;
            comment += `This PR originates from a forked repository. For security reasons, automatic preview deployments are restricted to the main repository.\n\n`;
            comment += `**Options:**\n`;
            comment += `- A repository maintainer can manually deploy a preview using the \`deploy-forked-pr-preview.yml\` workflow\n`;
            comment += `- The preview will use trusted base repository code (not fork changes)\n\n`;
          }

          if (!isOwner) {
            comment += `### üë§ Code Owner Required\n`;
            comment += `User \`@${targetUser}\` is not listed as a code owner in \`.github/CODEOWNERS\`.\n\n`;
            comment += `**To enable automatic preview deployments:**\n`;
            comment += `- Add \`@${targetUser}\` to the \`.github/CODEOWNERS\` file\n`;
            comment += `- Or have a code owner create the PR\n\n`;
          }

          comment += `### üîç Current Status\n`;
          comment += `- **Same repository:** ${isSameRepo ? '‚úÖ' : '‚ùå'}\n`;
          comment += `- **Code owner:** ${isOwner ? '‚úÖ' : '‚ùå'}\n`;
          comment += `- **User:** \`@${targetUser}\`\n\n`;
          comment += `---\n`;
          comment += `*For questions about preview environments, contact a repository maintainer.*`;

          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });

  # Change detection jobs (run in parallel to optimize workflow)
  check-backend-changes:
    name: Check Backend Changes
    runs-on: ubuntu-latest
    needs: [ validate-access ]
    outputs:
      has-backend-changes: ${{ steps.check.outputs.has-backend-changes }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Check for backend changes
      id: check
      run: |
        # Check if there are any backend-related changes in this PR
        BACKEND_CHANGES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | grep -E '^infrastructure/|^apps/express-api/|^\.github/workflows/deploy-preview\.yml|^\.github/actions/check-codeowner/' || true)

        if [[ -n "$BACKEND_CHANGES" ]]; then
          echo "‚úÖ Backend changes detected:"
          echo "$BACKEND_CHANGES"
          echo "has-backend-changes=true" >> $GITHUB_OUTPUT
        else
          echo "‚ÑπÔ∏è No backend changes detected, skipping backend deployment"
          echo "has-backend-changes=false" >> $GITHUB_OUTPUT
        fi

  check-frontend-changes:
    name: Check Frontend Changes
    runs-on: ubuntu-latest
    needs: [ validate-access ]
    outputs:
      has-frontend-changes: ${{ steps.check.outputs.has-frontend-changes }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Check for frontend changes
      id: check
      run: |
        # Check if there are any frontend-related changes in this PR
        FRONTEND_CHANGES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | grep -E '^apps/client-ui/|^\.github/actions/(discover-backend|generate-frontend-env)/' || true)

        if [[ -n "$FRONTEND_CHANGES" ]]; then
          echo "‚úÖ Frontend changes detected:"
          echo "$FRONTEND_CHANGES"
          echo "has-frontend-changes=true" >> $GITHUB_OUTPUT
        else
          echo "‚ÑπÔ∏è No frontend changes detected, skipping frontend deployment"
          echo "has-frontend-changes=false" >> $GITHUB_OUTPUT
        fi

  # Discover backend environment for frontend
  discover-backend-for-frontend:
    name: Discover Backend for Frontend
    runs-on: ubuntu-latest
    needs: [ validate-access, check-backend-changes, check-frontend-changes, deploy-backend-preview ]
    # Run if frontend has changes, regardless of whether backend was deployed or not
    if: |
      always() &&
      needs.validate-access.outputs.should-deploy == 'true' &&
      needs.check-frontend-changes.outputs.has-frontend-changes == 'true' &&
      (needs.deploy-backend-preview.result == 'success' || needs.deploy-backend-preview.result == 'skipped')

    permissions:
      id-token: write
      contents: read

    outputs:
      api-endpoint: ${{ steps.finalize.outputs.api-endpoint }}
      stack-name: ${{ steps.finalize.outputs.stack-name }}
      backend-found: ${{ steps.finalize.outputs.backend-found }}
      resolution-method: ${{ steps.finalize.outputs.resolution-method }}
      fallback-used: ${{ steps.finalize.outputs.fallback-used }}
      connectivity-status: ${{ steps.finalize.outputs.connectivity-status }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Download backend info artifact
      id: download-artifact
      continue-on-error: true
      uses: actions/download-artifact@v4
      with:
        name: backend-info-${{ needs.validate-access.outputs.env-name }}
        path: backend-info

    - name: Parse backend artifact
      id: artifact-parse
      run: |
        FILE="backend-info/backend-info.json"
        if [[ -f "$FILE" ]]; then
          API_ENDPOINT=$(jq -r '.api_endpoint // empty' "$FILE")
          STACK_NAME=$(jq -r '.stack_name // empty' "$FILE")
          HEALTH=$(jq -r '.health_status // empty' "$FILE")
          if [[ -n "$API_ENDPOINT" ]]; then
            echo "found=true" >> $GITHUB_OUTPUT
            echo "artifact-api-endpoint=$API_ENDPOINT" >> $GITHUB_OUTPUT
            echo "artifact-stack-name=$STACK_NAME" >> $GITHUB_OUTPUT
            echo "artifact-health=$HEALTH" >> $GITHUB_OUTPUT
          else
            echo "found=false" >> $GITHUB_OUTPUT
          fi
        else
          echo "found=false" >> $GITHUB_OUTPUT
        fi

    - name: Discover backend environment (fallback)
      id: discover
      if: steps.artifact-parse.outputs.found != 'true'
      uses: ./.github/actions/discover-backend
      with:
        environment: ${{ needs.validate-access.outputs.env-name }}
        pr-number: ${{ github.event.pull_request.number }}
        validate-connectivity: 'true'
        aws-region: ${{ env.AWS_REGION }}
        debug: 'false'

    - name: Finalize backend outputs
      id: finalize
      run: |
        if [[ "${{ steps.artifact-parse.outputs.found }}" == "true" ]]; then
          API_ENDPOINT="${{ steps.artifact-parse.outputs['artifact-api-endpoint'] }}"
          STACK_NAME="${{ steps.artifact-parse.outputs['artifact-stack-name'] }}"
          HEALTH="${{ steps.artifact-parse.outputs['artifact-health'] }}"
          if [[ -z "$HEALTH" || "$HEALTH" == "null" ]]; then HEALTH="unknown"; fi
          echo "api-endpoint=$API_ENDPOINT" >> $GITHUB_OUTPUT
          echo "stack-name=$STACK_NAME" >> $GITHUB_OUTPUT
          echo "backend-found=true" >> $GITHUB_OUTPUT
          echo "resolution-method=artifact" >> $GITHUB_OUTPUT
          echo "fallback-used=false" >> $GITHUB_OUTPUT
          echo "connectivity-status=$HEALTH" >> $GITHUB_OUTPUT
        else
          echo "api-endpoint=${{ steps.discover.outputs.api-endpoint }}" >> $GITHUB_OUTPUT
          echo "stack-name=${{ steps.discover.outputs.stack-name }}" >> $GITHUB_OUTPUT
          echo "backend-found=${{ steps.discover.outputs.backend-found }}" >> $GITHUB_OUTPUT
          echo "resolution-method=${{ steps.discover.outputs.resolution-method }}" >> $GITHUB_OUTPUT
          echo "fallback-used=${{ steps.discover.outputs.fallback-used }}" >> $GITHUB_OUTPUT
          echo "connectivity-status=${{ steps.discover.outputs.connectivity-status }}" >> $GITHUB_OUTPUT
        fi

  # Build the React frontend
  build-frontend:
    name: Build React Frontend
    runs-on: ubuntu-latest
    needs: [ validate-access, check-frontend-changes, discover-backend-for-frontend ]
    if: needs.validate-access.outputs.should-deploy == 'true' && needs.check-frontend-changes.outputs.has-frontend-changes == 'true'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install pnpm
      uses: pnpm/action-setup@v4
      with:
        version: ${{ env.PNPM_VERSION }}

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'pnpm'
        cache-dependency-path: 'pnpm-lock.yaml'

    - name: Install dependencies
      run: |
        cd apps/client-ui
        pnpm install --frozen-lockfile

    - name: Generate API client package
      env:
        # Minimal environment variables required for swagger generation
        # These are placeholder values that satisfy schema validation
        API_KEY: 'placeholder-api-key-for-swagger-generation-32chars'
        NODE_ENV: 'development'
        APP_ENV: 'development'
        SERVER_PORT: '3040'
        AWS_COGNITO_REGION: 'us-east-1'
        AWS_COGNITO_USER_POOL_ID: 'us-east-1_placeholder'
        AWS_COGNITO_USER_POOL_CLIENT_ID: 'placeholder-client-id'
        AWS_COGNITO_USER_POOL_SECRET_KEY: 'placeholder-secret-key'
        AWS_COGNITO_ACCESS_KEY: 'placeholder-access-key'
        AWS_COGNITO_SECRET_KEY: 'placeholder-secret-key'
        AWS_COGNITO_REFRESH_TOKEN_EXPIRY: '30'
        COOKIE_DOMAIN: 'localhost'
        COOKIE_ENCRYPTION_KEY: 'placeholder-cookie-encryption-key-32chars'
        NON_RELATIONAL_DATABASE_URL: 'redis://localhost:6379'
        RELATIONAL_DATABASE_URL: 'postgresql://localhost:5432/placeholder'
        OPENAI_API_KEY: 'sk-placeholder-openai-api-key-for-swagger-generation'
        RATE_LIMIT_WINDOW_MS: '900000'
        RATE_LIMIT_MAX_REQUESTS: '100'
        AUTH_RATE_LIMIT_WINDOW_MS: '3600000'
        AUTH_RATE_LIMIT_MAX_REQUESTS: '10'
        API_RATE_LIMIT_WINDOW_MS: '60000'
        API_RATE_LIMIT_MAX_REQUESTS: '60'
      run: |
        echo "üîß Generating API client package from OpenAPI specification"

        # Install dependencies for express-api to generate OpenAPI spec
        cd apps/express-api
        pnpm install --frozen-lockfile

        # Generate OpenAPI specification
        echo "üìã Generating OpenAPI specification..."
        pnpm run generate-swagger

        # Build the API client package (compile to dist for Vite)
        echo "üì¶ Building API client package..."
        cd ../../packages/macro-ai-api-client
        pnpm install --frozen-lockfile
        pnpm run build

        echo "‚úÖ API client package built successfully"

    - name: Generate environment configuration
      id: generate-env
      uses: ./.github/actions/generate-frontend-env
      with:
        environment: ${{ needs.validate-access.outputs.env-name }}
        pr-number: ${{ github.event.pull_request.number }}
        build-mode: 'preview'
        api-endpoint: ${{ needs.discover-backend-for-frontend.outputs.api-endpoint }}
        api-key: ${{ secrets.API_KEY }}
        backend-stack-name: ${{ needs.discover-backend-for-frontend.outputs.stack-name }}
        resolution-method: ${{ needs.discover-backend-for-frontend.outputs.resolution-method }}
        output-file: '.env.preview'
        include-build-metadata: 'true'
        validate-variables: 'true'
        debug: 'false'

    - name: Debug .env.preview (sanitized)
      if: always()
      run: |
        echo "### .env.preview (sanitized)" >> "$GITHUB_STEP_SUMMARY"
        if [ -f apps/client-ui/.env.preview ]; then
          sed -E 's/^(.*(SECRET|TOKEN|PASSWORD|API_KEY|KEY)=).*/\1<masked>/' apps/client-ui/.env.preview \
            >> "$GITHUB_STEP_SUMMARY"
        else
          echo "(apps/client-ui/.env.preview not found)" >> "$GITHUB_STEP_SUMMARY"
          echo "Contents of apps/client-ui:" >> "$GITHUB_STEP_SUMMARY"
          ls -la apps/client-ui >> "$GITHUB_STEP_SUMMARY"
        fi

    - name: Generate Amplify configuration
      run: |
        cd apps/client-ui

        ENV_NAME="${{ needs.validate-access.outputs.env-name }}"

        # Set environment variables for configuration generation
        export PR_NUMBER="${{ github.event.pull_request.number }}"
        export ENVIRONMENT_NAME="${ENV_NAME}"
        export BUILD_MODE="preview"
        export GITHUB_SHA="${{ github.sha }}"
        export GITHUB_REF_NAME="${{ github.ref_name }}"
        export GITHUB_PR_NUMBER="${{ github.event.pull_request.number }}"
        export PNPM_VERSION="${{ env.PNPM_VERSION }}"

        # Load environment variables from .env.preview using temporary file approach
        TEMP_ENV_FILE=$(mktemp)
        if grep '^[A-Za-z_][A-Za-z0-9_]*=' .env.preview > "$TEMP_ENV_FILE"; then
          echo "Found environment variables in .env.preview"
        else
          echo "No environment variables found in .env.preview"
          touch "$TEMP_ENV_FILE"
        fi

        # Export variables safely without sourcing (handles spaces, parentheses)
        if [[ -s "$TEMP_ENV_FILE" ]]; then
          while IFS= read -r line; do
            # Skip empty lines and comments
            [[ -z "$line" || "${line:0:1}" == "#" ]] && continue

            # Only process KEY=VALUE lines starting with a valid var name
            if [[ "$line" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
              key="${line%%=*}"
              value="${line#*=}"

              # Trim surrounding quotes if present
              if [[ "$value" == \"*\" && "$value" == *\" ]]; then
                value="${value:1:-1}"
              elif [[ "$value" == \'*\' && "$value" == *\' ]]; then
                value="${value:1:-1}"
              fi

              # Assign without eval, then export
              printf -v "$key" '%s' "$value"
              export "$key"
            fi
          done < "$TEMP_ENV_FILE"
          echo "‚úÖ Loaded $(wc -l < "$TEMP_ENV_FILE") environment variables"
        else
          echo "‚ö†Ô∏è No valid environment variables found in .env.preview"
        fi

        # Clean up temporary file
        rm -f "$TEMP_ENV_FILE"

        # Generate amplify.yml configuration using printf statements
        printf 'version: 1\n' > amplify.yml
        printf 'applications:\n' >> amplify.yml
        printf '  - appRoot: apps/client-ui\n' >> amplify.yml
        printf '    frontend:\n' >> amplify.yml
        printf '      phases:\n' >> amplify.yml
        printf '        preBuild:\n' >> amplify.yml
        printf '          commands:\n' >> amplify.yml
        printf '            - echo "Installing dependencies..."\n' >> amplify.yml
        printf '            - npm install -g pnpm@%s\n' "${PNPM_VERSION}" >> amplify.yml
        printf '            - pnpm install --frozen-lockfile\n' >> amplify.yml
        printf '        build:\n' >> amplify.yml
        printf '          commands:\n' >> amplify.yml
        printf '            - echo "Building React application..."\n' >> amplify.yml
        printf '            - pnpm run build\n' >> amplify.yml
        printf '      artifacts:\n' >> amplify.yml
        printf '        baseDirectory: dist\n' >> amplify.yml
        printf '        files:\n' >> amplify.yml
        printf '          - '\''**/*'\''\n' >> amplify.yml
        printf '      cache:\n' >> amplify.yml
        printf '        paths:\n' >> amplify.yml
        printf '          - node_modules/**/*\n' >> amplify.yml
        printf '          - .pnpm-store/**/*\n' >> amplify.yml

        echo "‚úÖ Generated amplify.yml configuration"

    - name: Build React application
      run: |
        cd apps/client-ui

        # Load environment variables using temporary file approach
        TEMP_ENV_FILE=$(mktemp)
        if grep '^[A-Za-z_][A-Za-z0-9_]*=' .env.preview > "$TEMP_ENV_FILE"; then
          echo "Found environment variables in .env.preview"
        else
          echo "No environment variables found in .env.preview"
          touch "$TEMP_ENV_FILE"
        fi

        if [[ -s "$TEMP_ENV_FILE" ]]; then
          while IFS= read -r line; do
            [[ -z "$line" || "${line:0:1}" == "#" ]] && continue
            if [[ "$line" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
              key="${line%%=*}"
              value="${line#*=}"
              if [[ "$value" == \"*\" && "$value" == *\" ]]; then
                value="${value:1:-1}"
              elif [[ "$value" == \'*\' && "$value" == *\' ]]; then
                value="${value:1:-1}"
              fi
              printf -v "$key" '%s' "$value"
              export "$key"
            fi
          done < "$TEMP_ENV_FILE"
          echo "‚úÖ Loaded environment variables for build"
        fi

        # Clean up temporary file
        rm -f "$TEMP_ENV_FILE"

        # Build the application
        echo "üî® Building React application..."
        pnpm run build

        echo "‚úÖ Build completed successfully"

        # Verify build output
        if [[ -d "dist" && -f "dist/index.html" ]]; then
          echo "‚úÖ Build artifacts verified"
          echo "üìä Build size: $(du -sh dist)"
        else
          echo "‚ùå Build verification failed"
          exit 1
        fi

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: frontend-build-${{ needs.validate-access.outputs.env-name }}
        path: apps/client-ui/dist/
        retention-days: 7

  # Deploy to AWS Amplify
  deploy-frontend:
    name: Deploy to AWS Amplify
    runs-on: ubuntu-latest
    needs: [ validate-access, check-frontend-changes, build-frontend, discover-backend-for-frontend ]
    if: needs.validate-access.outputs.should-deploy == 'true' && needs.check-frontend-changes.outputs.has-frontend-changes == 'true'

    permissions:
      id-token: write
      contents: read
      pull-requests: write
      issues: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: frontend-build-${{ needs.validate-access.outputs.env-name }}
        path: apps/client-ui/dist/

    - name: Deploy to Amplify
      id: deploy
      run: |
        cd apps/client-ui

        ENV_NAME="${{ needs.validate-access.outputs.env-name }}"
        AMPLIFY_APP_NAME="macro-ai-frontend-${ENV_NAME}"

        echo "üöÄ Deploying to Amplify app: ${AMPLIFY_APP_NAME}"

        # Check if Amplify app exists
        APP_ID=$(aws amplify list-apps --region ${{ env.AWS_REGION }} \
          --query "apps[?name=='${AMPLIFY_APP_NAME}'].appId" \
          --output text 2>/dev/null || echo "")

        if [[ -z "$APP_ID" || "$APP_ID" == "None" ]]; then
          echo "üì± Creating new Amplify app: ${AMPLIFY_APP_NAME}"

          # Create new Amplify app
          APP_ID=$(aws amplify create-app \
            --name "${AMPLIFY_APP_NAME}" \
            --description "Frontend preview for PR #${{ github.event.pull_request.number }}" \
            --platform WEB \
            --region ${{ env.AWS_REGION }} \
            --query 'app.appId' \
            --output text)

          echo "‚úÖ Created Amplify app with ID: ${APP_ID}"
        else
          echo "‚úÖ Using existing Amplify app with ID: ${APP_ID}"
        fi

        # Create or update branch
        BRANCH_NAME="${{ github.head_ref }}"
        echo "üåø Setting up branch: ${BRANCH_NAME}"

        # Check if branch exists
        BRANCH_EXISTS=$(aws amplify list-branches \
          --app-id "$APP_ID" \
          --region ${{ env.AWS_REGION }} \
          --query "branches[?branchName=='${BRANCH_NAME}'].branchName" \
          --output text 2>/dev/null || echo "")

        if [[ -z "$BRANCH_EXISTS" || "$BRANCH_EXISTS" == "None" ]]; then
          echo "üå± Creating new branch: ${BRANCH_NAME}"
          aws amplify create-branch \
            --app-id "$APP_ID" \
            --branch-name "${BRANCH_NAME}" \
            --description "Preview branch for PR #${{ github.event.pull_request.number }}" \
            --region ${{ env.AWS_REGION }}
        else
          echo "‚úÖ Branch already exists: ${BRANCH_NAME}"
        fi

        # Manual deployment flow (no repo connection required)
        echo "üöÄ Starting manual deployment via create-deployment..."

        # Ensure build artifacts exist and zip them
        if [[ -d "dist" ]]; then
          (cd dist && zip -qr ../build.zip .)
        else
          echo "‚ùå Build artifacts not found in apps/client-ui/dist"
          exit 1
        fi

        # Request a deployment to obtain jobId and pre-signed upload URL
        DEPLOY_JSON=$(aws amplify create-deployment \
          --app-id "$APP_ID" \
          --branch-name "${BRANCH_NAME}" \
          --region ${{ env.AWS_REGION }})
        JOB_ID=$(echo "$DEPLOY_JSON" | jq -r '.jobId')
        UPLOAD_URL=$(echo "$DEPLOY_JSON" | jq -r '.zipUploadUrl')

        if [[ -z "$JOB_ID" || -z "$UPLOAD_URL" || "$JOB_ID" == "null" || "$UPLOAD_URL" == "null" ]]; then
          echo "‚ùå Failed to create deployment or retrieve upload URL"
          exit 1
        fi

        echo "üìã Deployment job ID: ${JOB_ID}"
        echo "‚¨ÜÔ∏è Uploading build.zip to pre-signed URL"
        curl -sS -X PUT -H "Content-Type: application/zip" --upload-file build.zip "$UPLOAD_URL"

        # Start the deployment
        aws amplify start-deployment \
          --app-id "$APP_ID" \
          --branch-name "${BRANCH_NAME}" \
          --job-id "$JOB_ID" \
          --region ${{ env.AWS_REGION }}

        # Wait for deployment to complete (polling get-job since Amplify has no waiters)
        echo "‚è≥ Waiting for deployment to complete..."
        MAX_ATTEMPTS=90; SLEEP=10
        for ((i=1;i<=MAX_ATTEMPTS;i++)); do
          STATUS=$(aws amplify get-job \
            --app-id "$APP_ID" \
            --branch-name "${BRANCH_NAME}" \
            --job-id "$JOB_ID" \
            --region ${{ env.AWS_REGION }} \
            --query 'job.summary.status' \
            --output text)
          echo "üîé Attempt $i/$MAX_ATTEMPTS: status=${STATUS}"
          if [[ "$STATUS" == "SUCCEED" || "$STATUS" == "FAILED" || "$STATUS" == "CANCELLED" ]]; then
            break
          fi
          sleep $SLEEP
        done

        # Get deployment status
        JOB_STATUS=$(aws amplify get-job \
          --app-id "$APP_ID" \
          --branch-name "${BRANCH_NAME}" \
          --job-id "$JOB_ID" \
          --region ${{ env.AWS_REGION }} \
          --query 'job.summary.status' \
          --output text)

        if [[ "$JOB_STATUS" == "SUCCEED" ]]; then
          # Sanitize branch for Amplify subdomain: replace '/' with '-'
          SANITIZED_BRANCH="${BRANCH_NAME//\//-}"
          APP_URL="https://${SANITIZED_BRANCH}.${APP_ID}.amplifyapp.com/"
          echo "‚úÖ Deployment successful!"
          echo "üåê Frontend URL: ${APP_URL}"

          echo "app-id=${APP_ID}" >> $GITHUB_OUTPUT
          echo "app-url=${APP_URL}" >> $GITHUB_OUTPUT
          echo "job-id=${JOB_ID}" >> $GITHUB_OUTPUT
          echo "deployment-status=success" >> $GITHUB_OUTPUT
        else
          echo "‚ùå Deployment failed with status: ${JOB_STATUS}"
          echo "deployment-status=failed" >> $GITHUB_OUTPUT
          exit 1
        fi

    - name: Comment on PR with deployment details
      if: steps.deploy.outputs.deployment-status == 'success'
      uses: actions/github-script@v7
      with:
        script: |
          const appUrl = '${{ steps.deploy.outputs.app-url }}';
          const appId = '${{ steps.deploy.outputs.app-id }}';
          const jobId = '${{ steps.deploy.outputs.job-id }}';
          const envName = '${{ needs.validate-access.outputs.env-name }}';

          // Use finalized backend details (artifact-first)
          const backendUrl = '${{ needs.discover-backend-for-frontend.outputs.api-endpoint }}';
          const backendStack = '${{ needs.discover-backend-for-frontend.outputs.stack-name }}';

          const comment = `## üöÄ Preview Environment Deployed Successfully!

          ### üåê Preview URLs
          - **Frontend**: [${appUrl}](${appUrl})
          - **Backend API**: ${backendUrl}

          ### üìã Deployment Details
          - **Environment**: \`${envName}\`
          - **Amplify App ID**: \`${appId}\`
          - **Job ID**: \`${jobId}\`
          - **Branch**: \`${{ github.head_ref }}\`

          ### üîó Quick Links
          - [AWS Amplify Console](https://console.aws.amazon.com/amplify/home?region=${{ env.AWS_REGION }}#/${appId})
          - [Backend Stack](https://console.aws.amazon.com/cloudformation/home?region=${{ env.AWS_REGION }}#/stacks/stackinfo?stackId=${backendStack})

          ---
          *This preview environment will be automatically cleaned up when the PR is closed/merged.*`;

          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });

  # Summary job to show what was deployed
  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [ validate-access, check-backend-changes, check-frontend-changes, deploy-backend-preview, deploy-frontend ]
    if: always() && needs.validate-access.outputs.should-deploy == 'true'

    steps:
    - name: Generate deployment summary
      run: |
        echo "## üìã Deployment Summary for PR #${{ github.event.pull_request.number }}"
        echo ""

        # Backend deployment status
        BACKEND_CHANGES="${{ needs.check-backend-changes.outputs.has-backend-changes }}"
        BACKEND_RESULT="${{ needs.deploy-backend-preview.result }}"

        echo "### üîß Backend Deployment"
        if [[ "$BACKEND_CHANGES" == "true" ]]; then
          if [[ "$BACKEND_RESULT" == "success" ]]; then
            echo "‚úÖ **Backend deployed successfully** - Changes detected and deployed"
          elif [[ "$BACKEND_RESULT" == "failure" ]]; then
            echo "‚ùå **Backend deployment failed** - Check logs for details"
          else
            echo "‚è≥ **Backend deployment in progress** - Status: $BACKEND_RESULT"
          fi
        else
          echo "‚è≠Ô∏è **Backend deployment skipped** - No backend changes detected"
          echo "‚ÑπÔ∏è Using existing backend environment from previous deployment"
        fi
        echo ""

        # Frontend deployment status
        FRONTEND_CHANGES="${{ needs.check-frontend-changes.outputs.has-frontend-changes }}"
        FRONTEND_RESULT="${{ needs.deploy-frontend.result }}"

        echo "### üé® Frontend Deployment"
        if [[ "$FRONTEND_CHANGES" == "true" ]]; then
          if [[ "$FRONTEND_RESULT" == "success" ]]; then
            echo "‚úÖ **Frontend deployed successfully** - Changes detected and deployed"
          elif [[ "$FRONTEND_RESULT" == "failure" ]]; then
            echo "‚ùå **Frontend deployment failed** - Check logs for details"
          else
            echo "‚è≥ **Frontend deployment in progress** - Status: $FRONTEND_RESULT"
          fi
        else
          echo "‚è≠Ô∏è **Frontend deployment skipped** - No frontend changes detected"
          echo "‚ÑπÔ∏è Existing frontend deployment remains active"
        fi
        echo ""

        # Optimization summary
        echo "### ‚ö° Optimization Summary"
        if [[ "$BACKEND_CHANGES" == "true" && "$FRONTEND_CHANGES" == "true" ]]; then
          echo "üîÑ **Full deployment** - Both backend and frontend changes detected"
        elif [[ "$BACKEND_CHANGES" == "true" && "$FRONTEND_CHANGES" == "false" ]]; then
          echo "üîß **Backend-only deployment** - Optimized to skip frontend"
        elif [[ "$BACKEND_CHANGES" == "false" && "$FRONTEND_CHANGES" == "true" ]]; then
          echo "üé® **Frontend-only deployment** - Optimized to skip backend rebuild"
        else
          echo "‚è≠Ô∏è **No deployments needed** - No changes detected in either component"
        fi

        echo ""
        echo "---"
        echo "*This summary shows the optimized deployment strategy based on detected changes.*"
