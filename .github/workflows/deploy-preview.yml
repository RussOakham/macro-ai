name: Deploy PR Preview Environment

# TEMPORARILY DISABLED - Testing new deploy-feature.yml workflow
# on:
#   pull_request:
#     types: [opened, reopened, synchronize]
#     branches: [develop, main]
#     paths:
#       - 'infrastructure/**'
#       - 'apps/express-api/**'
#       - 'apps/client-ui/**'
#       - '.github/workflows/deploy-preview.yml'
#       - '.github/workflows/deploy-frontend-preview.yml'
#       - '.github/actions/check-codeowner/**'
#       - '.github/actions/discover-backend/**'
#       - '.github/actions/generate-frontend-env/**'

# Manual trigger only for testing
on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to test (e.g., 123)'
        required: true
        type: string
      confirm:
        description: 'Type "TEST PREVIEW" to confirm preview deployment'
        required: true
        type: string

permissions:
  contents: read
  actions: read
  pull-requests: write
  issues: write

env:
  AWS_REGION: us-east-1
  NODE_VERSION: '20.19.4'
  PNPM_VERSION: '10.14.0'
  # CDK environment variables
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  CDK_DEFAULT_ACCOUNT: ${{ secrets.AWS_ACCOUNT_ID }}
  CDK_DEFAULT_REGION: us-east-1
  # Custom domain configuration (optional)
  CUSTOM_DOMAIN_NAME: ${{ vars.CUSTOM_DOMAIN_NAME }}
  HOSTED_ZONE_ID: ${{ vars.HOSTED_ZONE_ID }}

jobs:
  # Check if PR author is a code owner and from same repo
  validate-access:
    name: Validate PR Access
    runs-on: ubuntu-latest

    permissions:
      id-token: write
      contents: read
      pull-requests: write
      issues: write
      actions: read

    outputs:
      is-owner: ${{ steps.codeowner-check.outputs.is-owner }}
      target-user: ${{ steps.codeowner-check.outputs.target-user }}
      is-same-repo: ${{ steps.repo-check.outputs.is-same-repo }}
      should-deploy: ${{ steps.decision.outputs.should-deploy }}
      env-name: ${{ steps.env-name.outputs.env-name }}
      # Pre-calculated URLs for parallel deployment
      amplify-app-id: ${{ steps.url-precalc.outputs.amplify-app-id }}
      frontend-url: ${{ steps.url-precalc.outputs.frontend-url }}
      backend-url: ${{ steps.url-precalc.outputs.backend-url }}
      backend-stack-name: ${{ steps.url-precalc.outputs.backend-stack-name }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Check repository ownership
        id: repo-check
        run: |
          if [[ "${{ github.event.pull_request.head.repo.full_name }}" == "${{ github.repository }}" ]]; then
            echo "is-same-repo=true" >> $GITHUB_OUTPUT
            echo "‚úÖ PR from same repository: ${{ github.event.pull_request.head.repo.full_name }}"
          else
            echo "is-same-repo=false" >> $GITHUB_OUTPUT
            echo "‚ùå PR from forked repository: ${{ github.event.pull_request.head.repo.full_name }}"
          fi

      - name: Check code ownership
        id: codeowner-check
        uses: ./.github/actions/check-codeowner
        with:
          mode: 'pr'
          base-ref: ${{ github.event.pull_request.base.ref }}

      - name: Generate environment name
        id: env-name
        run: |
          ENV_NAME="pr-${{ github.event.pull_request.number }}"
          echo "env-name=${ENV_NAME}" >> $GITHUB_OUTPUT
          echo "Environment name: ${ENV_NAME}"

      - name: Make deployment decision
        id: decision
        run: |
          IS_SAME_REPO="${{ steps.repo-check.outputs.is-same-repo }}"
          IS_OWNER="${{ steps.codeowner-check.outputs.is-owner }}"

          if [[ "${IS_SAME_REPO}" == "true" && "${IS_OWNER}" == "true" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Deployment approved: same-repo PR by code owner ${{ steps.codeowner-check.outputs.target-user }}"
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            echo "‚ùå Deployment blocked:"
            echo "  - Same repo: ${IS_SAME_REPO}"
            echo "  - Code owner: ${IS_OWNER}"
            echo "  - User: ${{ steps.codeowner-check.outputs.target-user }}"
          fi

      - name: Configure AWS credentials for URL precalculation
        if: steps.decision.outputs.should-deploy == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: github-actions-url-precalc
          aws-region: ${{ env.AWS_REGION }}

      - name: Calculate deployment names
        id: url-precalc
        if: steps.decision.outputs.should-deploy == 'true'
        run: |
          ENV_NAME="${{ steps.env-name.outputs.env-name }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"

          echo "üîç Calculating deployment names..."
          echo "Environment: $ENV_NAME"
          echo "PR Number: $PR_NUMBER"

          # Calculate stack name using same convention as CDK
          BACKEND_STACK_NAME="MacroAiPr-${PR_NUMBER}Stack"
          echo "üì¶ Backend Stack Name: $BACKEND_STACK_NAME"

          # Calculate URLs if custom domain is configured
          CUSTOM_DOMAIN_NAME="${{ vars.CUSTOM_DOMAIN_NAME || '' }}"
          if [[ -n "$CUSTOM_DOMAIN_NAME" ]]; then
            FRONTEND_URL="https://pr-${PR_NUMBER}.${CUSTOM_DOMAIN_NAME}"
            BACKEND_URL="https://pr-${PR_NUMBER}-api.${CUSTOM_DOMAIN_NAME}/api"
            echo "üåê Custom Domain URLs:"
            echo "  Frontend: $FRONTEND_URL"
            echo "  Backend: $BACKEND_URL"
          else
            FRONTEND_URL="<will-be-generated-during-deployment>"
            BACKEND_URL="<will-be-generated-during-deployment>"
            echo "üåê URLs will be generated during deployment"
          fi

          # Calculate Amplify app name and check if it exists
          AMPLIFY_APP_NAME="macro-ai-frontend-${ENV_NAME}"
          echo "üì± Checking for existing Amplify app: $AMPLIFY_APP_NAME"

          # Check if Amplify app already exists
          EXISTING_APP_ID=$(aws amplify list-apps \
            --region ${{ env.AWS_REGION }} \
            --query "apps[?name=='${AMPLIFY_APP_NAME}'].appId" \
            --output text 2>/dev/null || echo "")

          if [[ -n "$EXISTING_APP_ID" && "$EXISTING_APP_ID" != "None" ]]; then
            AMPLIFY_APP_ID="$EXISTING_APP_ID"
            echo "‚úÖ Found existing Amplify app with ID: $AMPLIFY_APP_ID"
          else
            AMPLIFY_APP_ID=""
            echo "üì± Amplify app will be created during deployment"
          fi

          # Output values
          echo "frontend-url=$FRONTEND_URL" >> $GITHUB_OUTPUT
          echo "backend-url=$BACKEND_URL" >> $GITHUB_OUTPUT
          echo "backend-stack-name=$BACKEND_STACK_NAME" >> $GITHUB_OUTPUT
          echo "amplify-app-id=$AMPLIFY_APP_ID" >> $GITHUB_OUTPUT

  # Build Express API Docker image and push to ECR
  build-express-api:
    name: Build Docker Image for ECS
    runs-on: ubuntu-latest
    needs: [validate-access]
    if: needs.validate-access.outputs.should-deploy == 'true'

    permissions:
      id-token: write
      contents: read
      actions: write # For uploading artifacts

    outputs:
      image-uri: ${{ steps.build.outputs.image-uri }}
      image-tag: ${{ steps.build.outputs.image-tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Cache pnpm dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.pnpm-store
            node_modules
          key: pnpm-${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            pnpm-${{ runner.os }}-

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: github-actions-build-docker-ecs
          aws-region: ${{ env.AWS_REGION }}

      - name: Debug AWS credentials
        run: |
          echo "üîç Debugging AWS credentials..."
          echo "AWS_REGION: ${{ env.AWS_REGION }}"
          echo "AWS_DEFAULT_REGION: $AWS_DEFAULT_REGION"
          echo "AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}"

          # Test AWS CLI access
          echo "Testing AWS CLI access..."
          aws sts get-caller-identity --no-cli-pager

          # Test Parameter Store access
          echo "Testing Parameter Store access..."
          aws ssm describe-parameters --max-items 1 --no-cli-pager || echo "‚ùå Parameter Store access failed"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Debug ECR login outputs
        run: |
          echo "üîç Debugging ECR login outputs..."
          echo "Registry output: '${{ steps.login-ecr.outputs.registry }}'"
          echo "All outputs:"
          echo "${{ toJSON(steps.login-ecr.outputs) }}"

      - name: Generate image tag
        id: image-tag
        run: |
          IMAGE_TAG="pr-${{ github.event.pull_request.number }}-${{ github.sha }}"
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "Generated image tag: ${IMAGE_TAG}"

      - name: Generate environment file from Parameter Store
        id: generate-env
        run: |
          echo "üîç Fetching environment variables from AWS Parameter Store..."

          # Determine environment based on branch/context
          # PR/Preview branches use development, future: staging/production
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENV_NAME="production"
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            ENV_NAME="staging"
          else
            # PR branches and feature branches use development
            ENV_NAME="development"
          fi

          # Construct Parameter Store path with proper prefix
          PARAM_PATH="/macro-ai/${ENV_NAME}"
          ENV_FILE="apps/express-api/.env.docker"

          echo "üåç Environment: ${ENV_NAME}"
          echo "üì• Fetching from: ${PARAM_PATH}"

          # Create the environment file using our script with GitHub secrets
          chmod +x apps/express-api/scripts/generate-env-from-parameter-store.sh

          # Set APP_ENV for the new programmatic approach
          # For PR deployments, this should be the PR number (e.g., pr-123)
          # The script will automatically determine the parameter store prefix:
          # - pr-* environments ‚Üí /macro-ai/development/
          # - development ‚Üí /macro-ai/development/
          # - staging ‚Üí /macro-ai/staging/
          # - production ‚Üí /macro-ai/production/
          APP_ENV="pr-${{ github.event.pull_request.number }}"

          # Pass GitHub secrets as environment variables for the script
          # Note: PARAMETER_STORE_PREFIX is no longer needed - the script determines it from APP_ENV
          # The script will automatically use /macro-ai/development/ for preview environments (pr-*)
          ENV_FILE="${ENV_FILE}" \
          AWS_REGION="${{ env.AWS_REGION }}" \
          APP_ENV="${APP_ENV}" \
          API_KEY="${{ secrets.API_KEY }}" \
          OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}" \
          AWS_ACCOUNT_ID="${{ secrets.AWS_ACCOUNT_ID }}" \
          AWS_ROLE_ARN="${{ secrets.AWS_ROLE_ARN }}" \
          SERVER_PORT="${{ secrets.SERVER_PORT }}" \
          RATE_LIMIT_WINDOW_MS="${{ secrets.RATE_LIMIT_WINDOW_MS }}" \
          RATE_LIMIT_MAX_REQUESTS="${{ secrets.RATE_LIMIT_MAX_REQUESTS }}" \
          AUTH_RATE_LIMIT_WINDOW_MS="${{ secrets.AUTH_RATE_LIMIT_WINDOW_MS }}" \
          AUTH_RATE_LIMIT_MAX_REQUESTS="${{ secrets.AUTH_RATE_LIMIT_MAX_REQUESTS }}" \
          API_RATE_LIMIT_WINDOW_MS="${{ secrets.API_RATE_LIMIT_WINDOW_MS }}" \
          API_RATE_LIMIT_MAX_REQUESTS="${{ secrets.API_RATE_LIMIT_MAX_REQUESTS }}" \
          COST_ALERT_EMAILS="${{ secrets.COST_ALERT_EMAILS }}" \
          ./apps/express-api/scripts/generate-env-from-parameter-store.sh

          echo "‚úÖ Environment file generated from ${ENV_NAME} environment"
          echo "env-file=${ENV_FILE}" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        id: build
        run: |
          # Determine environment for ECR repository naming
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENV_NAME="production"
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            ENV_NAME="staging"
          else
            ENV_NAME="development"
          fi

          ECR_REPOSITORY="macro-ai-${ENV_NAME}-express-api"
          IMAGE_TAG="${{ steps.image-tag.outputs.image-tag }}"

          # Try to get registry from ECR login output, fallback to account ID
          ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"
          if [[ -z "${ECR_REGISTRY}" ]]; then
            echo "‚ö†Ô∏è  ECR registry output is empty, using fallback from AWS account ID"
            ECR_REGISTRY="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          fi

          IMAGE_URI="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"

          echo "üê≥ Building Docker image..."
          echo "üåç Environment: ${ENV_NAME}"
          echo "Repository: ${ECR_REPOSITORY}"
          echo "Tag: ${IMAGE_TAG}"
          echo "Registry: ${ECR_REGISTRY}"
          echo "URI: ${IMAGE_URI}"

          # Validate that all required variables are set
          if [[ -z "${IMAGE_TAG}" ]]; then
            echo "‚ùå Error: IMAGE_TAG is empty"
            exit 1
          fi

          if [[ -z "${ECR_REGISTRY}" ]]; then
            echo "‚ùå Error: ECR registry is empty"
            exit 1
          fi

          if [[ -z "${IMAGE_URI}" ]]; then
            echo "‚ùå Error: IMAGE_URI is empty after construction"
            exit 1
          fi

          # Build with environment file using BuildKit
          docker buildx build \
            --file apps/express-api/Dockerfile.distroless \
            --target ecs-runner \
            --platform linux/amd64 \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            --build-arg ENV_FILE="${{ steps.generate-env.outputs.env-file }}" \
            --tag "${IMAGE_URI}" \
            --push \
            .

          # Create ECR repository if it doesn't exist
          echo "üîß Ensuring ECR repository exists..."
          aws ecr describe-repositories --repository-names "${ECR_REPOSITORY}" >/dev/null 2>&1 || {
            echo "üì¶ Creating ECR repository: ${ECR_REPOSITORY}"
            aws ecr create-repository \
              --repository-name "${ECR_REPOSITORY}" \
              --image-scanning-configuration scanOnPush=true \
              --encryption-configuration encryptionType=AES256
          }

          echo "‚úÖ Image built and pushed successfully with BuildKit!"
          echo "image-uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT

          # Debug: Check what was written to GITHUB_OUTPUT
          echo "üîç Debug: Checking GITHUB_OUTPUT contents..."
          if [[ -f "$GITHUB_OUTPUT" ]]; then
            echo "GITHUB_OUTPUT file contents:"
            cat "$GITHUB_OUTPUT"
          else
            echo "GITHUB_OUTPUT file not found"
          fi

          # Save image URI to artifact for persistence and debugging
          echo "${IMAGE_URI}" > image-uri.txt
          echo "${IMAGE_TAG}" > image-tag.txt

      - name: Upload Docker image artifacts
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-info
          path: |
            image-uri.txt
            image-tag.txt
          retention-days: 30

      - name: Cleanup environment file
        if: always()
        run: |
          ENV_FILE="${{ steps.generate-env.outputs.env-file }}"
          if [[ -f "${ENV_FILE}" ]]; then
            rm -f "${ENV_FILE}"
            echo "üßπ Cleaned up: ${ENV_FILE}"
          fi

      - name: Verify outputs
        run: |
          echo "üîç Verifying build job outputs..."
          echo "steps.build.outputs.image-uri: '${{ steps.build.outputs.image-uri }}'"
          echo "steps.build.outputs.image-tag: '${{ steps.build.outputs.image-tag }}'"

  # Deploy ECS Preview Environment (Docker-based infrastructure)
  deploy-backend-preview:
    name: Deploy ECS Preview
    runs-on: ubuntu-latest
    needs: [validate-access, build-express-api]
    if: needs.validate-access.outputs.should-deploy == 'true'
    environment: development

    permissions:
      id-token: write
      contents: read
      pull-requests: write
      issues: write

    outputs:
      api-endpoint: ${{ steps.deploy.outputs.api-endpoint }}
      stack-name: ${{ steps.deploy.outputs.stack-name }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker image artifacts
        uses: actions/download-artifact@v4
        with:
          name: docker-image-info
          path: ./

      - name: Debug artifacts
        run: |
          echo "üîç Checking downloaded artifacts..."
          ls -la
          if [[ -f "image-uri.txt" ]]; then
            echo "‚úÖ image-uri.txt found:"
            cat image-uri.txt
          else
            echo "‚ùå image-uri.txt not found"
          fi
          if [[ -f "image-tag.txt" ]]; then
            echo "‚úÖ image-tag.txt found:"
            cat image-tag.txt
          else
            echo "‚ùå image-tag.txt not found"
          fi

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Cache pnpm dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.pnpm-store
            node_modules
          key: pnpm-${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            pnpm-${{ runner.os }}-

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-ECS-Preview-Deploy-${{ github.run_id }}

      - name: Install AWS CDK CLI
        run: pnpm add -g aws-cdk@2

      - name: Deploy ECS Infrastructure
        id: deploy
        env:
          CDK_DEPLOY_ENV: ${{ needs.validate-access.outputs.env-name }}
          CDK_DEPLOY_TYPE: 'ecs-preview'
          CDK_DEPLOY_SCALE: 'preview'
          PR_NUMBER: ${{ github.event.pull_request.number }}
          CUSTOM_DOMAIN_NAME: ${{ vars.CUSTOM_DOMAIN_NAME }}
        run: |
          ENV_NAME="${{ needs.validate-access.outputs.env-name }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"

          # Debug: Check all available outputs
          echo "üîç Debugging job outputs..."
          echo "needs.build-express-api.outputs:"
          echo "  image-uri: '${{ needs.build-express-api.outputs.image-uri }}'"
          echo "  image-tag: '${{ needs.build-express-api.outputs.image-tag }}'"
          echo "needs.validate-access.outputs:"
          echo "  env-name: '${{ needs.validate-access.outputs.env-name }}'"
          echo "  should-deploy: '${{ needs.validate-access.outputs.should-deploy }}'"

          # Debug: Check if the build job completed successfully
          echo "üîç Build job status:"
          echo "  Job name: build-express-api"
          echo "  Job status: ${{ needs.build-express-api.result }}"
          echo "  Job outputs available: ${{ contains(needs.build-express-api.outputs, 'image-uri') }}"

          # Check if build job completed successfully
          if [[ "${{ needs.build-express-api.result }}" != "success" ]]; then
            echo "‚ùå Build job did not complete successfully: ${{ needs.build-express-api.result }}"
            exit 1
          fi

          # Try to get IMAGE_URI from job output first, fallback to artifact
          IMAGE_URI="${{ needs.build-express-api.outputs.image-uri }}"

          # If IMAGE_URI is empty, try to read from artifact
          if [[ -z "${IMAGE_URI}" ]]; then
            echo "‚ö†Ô∏è  IMAGE_URI from job output is empty, trying artifact fallback..."
            if [[ -f "image-uri.txt" ]]; then
              IMAGE_URI=$(cat image-uri.txt)
              echo "‚úÖ Retrieved IMAGE_URI from artifact: ${IMAGE_URI}"
            else
              echo "‚ùå No IMAGE_URI found in job output or artifact"
              exit 1
            fi
          fi

          echo "üöÄ Deploying ECS Preview Environment"
          echo "Environment: ${ENV_NAME}"
          echo "PR Number: ${PR_NUMBER}"
          echo "Image URI: ${IMAGE_URI}"

          # Now change to infrastructure directory for CDK deployment
          cd infrastructure
          pnpm install --frozen-lockfile
          pnpm build

          # Deploy the ECS stack
          STACK_NAME="MacroAiPr-${PR_NUMBER}Stack"

          # Parse cost alert emails from comma-separated string to individual context values
          # Handle both single email and comma-separated emails with whitespace
          echo "üîç Parsing cost alert emails from secret..."

          # Check if the secret contains comma-separated values or single email
          if [[ "${{ secrets.COST_ALERT_EMAILS }}" == *","* ]]; then
            # Multiple emails - split by comma and clean up
            COST_ALERT_EMAILS_LIST=$(echo "${{ secrets.COST_ALERT_EMAILS }}" | tr ',' '\n' | awk '{$1=$1};1' | grep -v '^$')
          else
            # Single email
            COST_ALERT_EMAILS_LIST="${{ secrets.COST_ALERT_EMAILS }}"
          fi

          # Convert to array for CDK context (CDK expects individual context values, not JSON array)
          COST_ALERT_EMAILS_ARRAY=()
          while IFS= read -r email; do
            if [[ -n "$email" ]]; then
              COST_ALERT_EMAILS_ARRAY+=("$email")
            fi
          done <<< "$COST_ALERT_EMAILS_LIST"

          # Log only the count of emails for debugging without exposing sensitive data
          EMAIL_COUNT=${#COST_ALERT_EMAILS_ARRAY[@]}
          echo "üìß Parsed ${EMAIL_COUNT} cost alert email(s)"

          # Build CDK context arguments for cost alert emails
          CDK_CONTEXT_ARGS=""
          for email in "${COST_ALERT_EMAILS_ARRAY[@]}"; do
            CDK_CONTEXT_ARGS="${CDK_CONTEXT_ARGS} --context costAlertEmails=${email}"
          done

          cdk deploy "${STACK_NAME}" \
            --context environmentName="${ENV_NAME}" \
            --context prNumber="${PR_NUMBER}" \
            --context branchName="${{ github.head_ref }}" \
            --context imageUri="${IMAGE_URI}" \
            ${CDK_CONTEXT_ARGS} \
            --require-approval never \
            --outputs-file cdk-outputs.json

          echo "‚úÖ ECS deployment completed"

          # Extract outputs
          API_ENDPOINT=$(aws cloudformation describe-stacks \
            --stack-name "${STACK_NAME}" \
            --query "Stacks[0].Outputs[?OutputKey=='ApiEndpoint'].OutputValue" \
            --output text 2>/dev/null || echo "")

          echo "stack-name=${STACK_NAME}" >> $GITHUB_OUTPUT
          echo "api-endpoint=${API_ENDPOINT}" >> $GITHUB_OUTPUT

          echo "üåê API Endpoint: ${API_ENDPOINT}"

      - name: Health check
        id: health-check
        run: |
          API_ENDPOINT="${{ steps.deploy.outputs.api-endpoint }}"

          # Check if we have a custom domain URL from validate-access
          CUSTOM_BACKEND_URL="${{ needs.validate-access.outputs.backend-url }}"

          # Use custom domain URL if available and it's HTTPS (custom domain), otherwise fall back to ALB
          if [[ -n "${CUSTOM_BACKEND_URL}" && "${CUSTOM_BACKEND_URL}" == https://* ]]; then
            HEALTH_URL="${CUSTOM_BACKEND_URL%/}/health"
            echo "üîç Testing custom domain health endpoint: ${HEALTH_URL}"
          elif [[ -n "${API_ENDPOINT}" ]]; then
            HEALTH_URL="${API_ENDPOINT%/}/health"
            echo "üîç Testing ALB health endpoint: ${HEALTH_URL}"
          else
            echo "health-status=unknown" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Cannot perform health check - no API endpoint"
            exit 0
          fi

          # Wait a moment for deployment to stabilize
          sleep 10

          # Test health endpoint with retries
          for i in {1..3}; do
            HEALTH_RESPONSE=$(curl -sS -o /dev/null -w "%{http_code}" --max-time 10 --connect-timeout 5 "${HEALTH_URL}" 2>/dev/null || echo "000")
            if [[ "$HEALTH_RESPONSE" == "200" ]]; then
              echo "health-status=healthy" >> $GITHUB_OUTPUT
              echo "‚úÖ Health check passed (attempt $i)"
              break
            else
              echo "‚ö†Ô∏è Health check failed (attempt $i): $HEALTH_RESPONSE"
              if [[ $i -eq 3 ]]; then
                echo "health-status=unhealthy" >> $GITHUB_OUTPUT
              fi
              sleep 5
            fi
          done

      - name: Create deployment URLs artifact
        if: always()
        run: |
          echo "üì¶ Creating deployment URLs artifact..."
          mkdir -p deployment-urls

          # Create deployment URLs file with actual deployed values
          jq -n \
            --arg backend_url "${{ steps.deploy.outputs.api-endpoint }}" \
            --arg frontend_url "${{ needs.validate-access.outputs.frontend-url }}" \
            --arg backend_stack_name "${{ steps.deploy.outputs.stack-name }}" \
            --arg environment "${{ needs.validate-access.outputs.env-name }}" \
            --arg deployment_type "backend_deployed" \
            --arg health_status "${{ steps.health-check.outputs.health-status }}" \
            --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            '{
              backend_url: $backend_url,
              frontend_url: $frontend_url,
              backend_stack_name: $backend_stack_name,
              environment: $environment,
              deployment_type: $deployment_type,
              health_status: $health_status,
              timestamp: $timestamp
            }' > deployment-urls/urls.json

          echo "‚úÖ Deployment URLs artifact created:"
          cat deployment-urls/urls.json

      - name: Upload deployment URLs artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-urls-${{ needs.validate-access.outputs.env-name }}
          path: deployment-urls/
          retention-days: 1
          if-no-files-found: ignore

  # Handle blocked deployments (forked PRs or non-code-owners)
  explain-blocked:
    name: Explain Blocked Deployment
    runs-on: ubuntu-latest
    needs: validate-access
    if: needs.validate-access.outputs.should-deploy == 'false'

    permissions:
      pull-requests: write

    steps:
      - name: Comment on blocked PR
        uses: actions/github-script@v7
        with:
          script: |
            const isSameRepo = '${{ needs.validate-access.outputs.is-same-repo }}' === 'true';
            const isOwner = '${{ needs.validate-access.outputs.is-owner }}' === 'true';
            const targetUser = '${{ needs.validate-access.outputs.target-user }}';

            let comment = `## üö´ Preview Environment Deployment Blocked\n\n`;

            if (!isSameRepo) {
              comment += `### üîí Forked Repository\n`;
              comment += `This PR originates from a forked repository. For security reasons, automatic preview deployments are restricted to the main repository.\n\n`;
              comment += `**Options:**\n`;
              comment += `- A repository maintainer can manually deploy a preview using the \`deploy-forked-pr-preview.yml\` workflow\n`;
              comment += `- The preview will use trusted base repository code (not fork changes)\n\n`;
            }

            if (!isOwner) {
              comment += `### üë§ Code Owner Required\n`;
              comment += `User \`@${targetUser}\` is not listed as a code owner in \`.github/CODEOWNERS\`.\n\n`;
              comment += `**To enable automatic preview deployments:**\n`;
              comment += `- Add \`@${targetUser}\` to the \`.github/CODEOWNERS\` file\n`;
              comment += `- Or have a code owner create the PR\n\n`;
            }

            comment += `### üîç Current Status\n`;
            comment += `- **Same repository:** ${isSameRepo ? '‚úÖ' : '‚ùå'}\n`;
            comment += `- **Code owner:** ${isOwner ? '‚úÖ' : '‚ùå'}\n`;
            comment += `- **User:** \`@${targetUser}\`\n\n`;
            comment += `---\n`;
            comment += `*For questions about preview environments, contact a repository maintainer.*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  # Change detection jobs (run in parallel to optimize workflow)
  check-backend-changes:
    name: Check Backend Changes
    runs-on: ubuntu-latest
    needs: [validate-access]

    permissions:
      contents: read

    outputs:
      has-backend-changes: ${{ steps.check.outputs.has-backend-changes }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for backend changes
        id: check
        run: |
          # Check if there are any backend-related changes in this PR
          BACKEND_CHANGES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | grep -E '^infrastructure/|^apps/express-api/|^\.github/workflows/deploy-preview\.yml|^\.github/actions/check-codeowner/' || true)

          if [[ -n "$BACKEND_CHANGES" ]]; then
            echo "‚úÖ Backend changes detected:"
            echo "$BACKEND_CHANGES"
            echo "has-backend-changes=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No backend changes detected, skipping backend deployment"
            echo "has-backend-changes=false" >> $GITHUB_OUTPUT
          fi

  check-frontend-changes:
    name: Check Frontend Changes
    runs-on: ubuntu-latest
    needs: [validate-access]
    permissions:
      id-token: write
      contents: read
    outputs:
      has-frontend-changes: ${{ steps.check.outputs.has-frontend-changes }}
      existing-amplify-app-id: ${{ steps.check.outputs.existing-amplify-app-id }}
      should-deploy-frontend: ${{ steps.check.outputs.should-deploy-frontend }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: github-actions-check-frontend-changes
          aws-region: ${{ env.AWS_REGION }}

      - name: Check for frontend changes and existing app
        id: check
        run: |
          # Check if there are any frontend-related changes in this PR
          FRONTEND_CHANGES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | grep -E '^apps/client-ui/|^\.github/actions/(discover-backend|generate-frontend-env)/' || true)

          # Check if an Amplify app already exists for this branch
          ENV_NAME="${{ needs.validate-access.outputs.env-name }}"
          AMPLIFY_APP_NAME="macro-ai-frontend-${ENV_NAME}"

          echo "üîç Checking for existing Amplify app: ${AMPLIFY_APP_NAME}"

          # Check if Amplify app already exists
          EXISTING_APP_ID=$(aws amplify list-apps \
            --region ${{ env.AWS_REGION }} \
            --query "apps[?name=='${AMPLIFY_APP_NAME}'].appId" \
            --output text 2>/dev/null || echo "")

          if [[ -n "$EXISTING_APP_ID" && "$EXISTING_APP_ID" != "None" ]]; then
            echo "‚úÖ Found existing Amplify app with ID: $EXISTING_APP_ID"
            echo "existing-amplify-app-id=$EXISTING_APP_ID" >> $GITHUB_OUTPUT
            
            # Check if the app has a branch for this PR
            BRANCH_NAME="${{ github.head_ref }}"
            SANITIZED_BRANCH="${BRANCH_NAME//\//-}"
            
            BRANCH_EXISTS=$(aws amplify list-branches \
              --app-id "$EXISTING_APP_ID" \
              --region ${{ env.AWS_REGION }} \
              --query "branches[?branchName=='${SANITIZED_BRANCH}'].branchName" \
              --output text 2>/dev/null || echo "")
            
            if [[ -n "$BRANCH_EXISTS" ]]; then
              echo "‚úÖ Branch ${SANITIZED_BRANCH} already exists in Amplify app"
              HAS_EXISTING_BRANCH=true
            else
              echo "‚ÑπÔ∏è Branch ${SANITIZED_BRANCH} doesn't exist in Amplify app"
              HAS_EXISTING_BRANCH=false
            fi
          else
            echo "üì± No existing Amplify app found"
            echo "existing-amplify-app-id=" >> $GITHUB_OUTPUT
            HAS_EXISTING_BRANCH=false
          fi

          # Determine if we should deploy frontend
          if [[ -n "$FRONTEND_CHANGES" ]]; then
            echo "‚úÖ Frontend changes detected:"
            echo "$FRONTEND_CHANGES"
            echo "has-frontend-changes=true" >> $GITHUB_OUTPUT
            echo "should-deploy-frontend=true" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è Frontend deployment required due to changes"
          elif [[ "$HAS_EXISTING_BRANCH" == "true" ]]; then
            echo "‚ÑπÔ∏è No frontend changes detected, but existing Amplify app with branch found"
            echo "has-frontend-changes=false" >> $GITHUB_OUTPUT
            echo "should-deploy-frontend=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è Skipping frontend deployment - reusing existing app"
          else
            echo "‚ÑπÔ∏è No frontend changes detected, but no existing Amplify app/branch found"
            echo "has-frontend-changes=false" >> $GITHUB_OUTPUT
            echo "should-deploy-frontend=true" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è Frontend deployment required to create new app/branch"
          fi

  # Handle existing frontend app when no deployment needed
  handle-existing-frontend:
    name: Handle Existing Frontend App
    runs-on: ubuntu-latest
    needs: [validate-access, check-frontend-changes]
    if: |
      needs.validate-access.outputs.should-deploy == 'true' &&
      needs.check-frontend-changes.outputs.should-deploy-frontend == 'false' &&
      needs.check-frontend-changes.outputs.existing-amplify-app-id != ''

    permissions:
      id-token: write
      contents: read

    outputs:
      env-name: ${{ needs.validate-access.outputs.env-name }}
      amplify-app-id: ${{ needs.check-frontend-changes.outputs.existing-amplify-app-id }}
      backend-url: ${{ needs.validate-access.outputs.backend-url }}
      backend-stack-name: ${{ needs.validate-access.outputs.backend-stack-name }}
      frontend-url: ${{ steps.resolve-url.outputs.frontend-url }}
      target-user: ${{ needs.validate-access.outputs.target-user }}
      app-url: ${{ steps.resolve-url.outputs.frontend-url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: github-actions-handle-existing-frontend
          aws-region: ${{ env.AWS_REGION }}

      - name: Resolve existing frontend URL
        id: resolve-url
        run: |
          ENV_NAME="${{ needs.validate-access.outputs.env-name }}"
          APP_ID="${{ needs.check-frontend-changes.outputs.existing-amplify-app-id }}"
          BRANCH_NAME="${{ github.head_ref }}"
          SANITIZED_BRANCH="${BRANCH_NAME//\//-}"

          echo "üîç Resolving URL for existing Amplify app: ${APP_ID}"
          echo "üåø Branch: ${BRANCH_NAME} (sanitized: ${SANITIZED_BRANCH})"

          # Check if custom domain is configured
          if [[ -n "${{ vars.CUSTOM_DOMAIN_NAME }}" ]]; then
            # Use custom domain pattern
            FRONTEND_URL="https://pr-${{ github.event.pull_request.number }}.${{ vars.CUSTOM_DOMAIN_NAME }}"
            echo "üåê Using custom domain: ${FRONTEND_URL}"
          else
            # Get the default Amplify URL for the existing app/branch
            echo "üì± Getting default Amplify URL for existing app..."
            
            # Get the branch details to find the URL
            BRANCH_INFO=$(aws amplify get-branch \
              --app-id "${APP_ID}" \
              --branch-name "${BRANCH_NAME}" \
              --region ${{ env.AWS_REGION }} \
              --query 'branch.branchArn' \
              --output text 2>/dev/null || echo "")
            
            if [[ -n "$BRANCH_INFO" ]]; then
              # Extract the URL from the branch ARN
              # Format: arn:aws:amplify:region:account:apps/appId/branches/branchName
              FRONTEND_URL="https://${SANITIZED_BRANCH}.${APP_ID}.amplifyapp.com"
              echo "üåê Using default Amplify URL: ${FRONTEND_URL}"
            else
              echo "‚ö†Ô∏è Could not resolve branch URL, using fallback"
              FRONTEND_URL="https://${SANITIZED_BRANCH}.${APP_ID}.amplifyapp.com"
            fi
          fi

          echo "frontend-url=${FRONTEND_URL}" >> $GITHUB_OUTPUT
          echo "‚úÖ Resolved frontend URL: ${FRONTEND_URL}"

  # Build the React frontend
  build-frontend:
    name: Build React Frontend
    runs-on: ubuntu-latest
    needs: [validate-access, check-frontend-changes]
    # Run if frontend changes detected - simplified condition for custom domain optimization
    if: |
      needs.validate-access.outputs.should-deploy == 'true' &&
      needs.check-frontend-changes.outputs.should-deploy-frontend == 'true'

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions-BuildFrontend-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Cache pnpm dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.pnpm-store
            node_modules
          key: pnpm-${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            pnpm-${{ runner.os }}-

      - name: Install dependencies
        run: |
          cd apps/client-ui
          pnpm install --frozen-lockfile

      - name: Generate API client package
        env:
          # Minimal environment variables required for swagger generation
          # These are placeholder values that satisfy schema validation
          API_KEY: 'placeholder-api-key-for-swagger-generation-32chars'
          NODE_ENV: 'development'
          APP_ENV: 'development'
          SERVER_PORT: '3040'
          AWS_COGNITO_REGION: 'us-east-1'
          AWS_COGNITO_USER_POOL_ID: 'us-east-1_placeholder'
          AWS_COGNITO_USER_POOL_CLIENT_ID: 'placeholder-client-id'
          # AWS Cognito credentials removed - using IAM roles instead
          AWS_COGNITO_REFRESH_TOKEN_EXPIRY: '30'
          COOKIE_DOMAIN: 'localhost'
          COOKIE_ENCRYPTION_KEY: 'placeholder-cookie-encryption-key-32chars'
          REDIS_URL: 'redis://localhost:6379'
          RELATIONAL_DATABASE_URL: 'postgresql://localhost:5432/placeholder'
          OPENAI_API_KEY: 'sk-placeholder-openai-api-key-for-swagger-generation'
          RATE_LIMIT_WINDOW_MS: '900000'
          RATE_LIMIT_MAX_REQUESTS: '100'
          AUTH_RATE_LIMIT_WINDOW_MS: '3600000'
          AUTH_RATE_LIMIT_MAX_REQUESTS: '10'
          API_RATE_LIMIT_WINDOW_MS: '60000'
          API_RATE_LIMIT_MAX_REQUESTS: '60'
          COST_ALERT_EMAILS: 'placeholder-cost-alert-emails' # Placeholder for testing
        run: |
          echo "üîß Generating API client package from OpenAPI specification"

          # Install dependencies for express-api to generate OpenAPI spec
          cd apps/express-api
          pnpm install --frozen-lockfile

          # Generate OpenAPI specification
          echo "üìã Generating OpenAPI specification..."
          pnpm run generate-swagger

          # Build the API client package (compile to dist for Vite)
          echo "üì¶ Building API client package..."
          cd ../../packages/macro-ai-api-client
          pnpm install --frozen-lockfile
          pnpm run build

          echo "‚úÖ API client package built successfully"

      - name: Resolve backend URL
        id: resolve-backend
        run: |
          echo "üîç Resolving backend URL for frontend configuration..."

          if [[ -n "${{ vars.CUSTOM_DOMAIN_NAME }}" ]]; then
            # Use custom domain pattern
            BACKEND_URL="https://pr-${{ github.event.pull_request.number }}-api.${{ vars.CUSTOM_DOMAIN_NAME }}/api"
            echo "üåê Using custom domain: $BACKEND_URL"
          else
            # Use pre-calculated URL from validation step
            BACKEND_URL="${{ needs.validate-access.outputs.backend-url }}"
            echo "üåê Using pre-calculated URL: $BACKEND_URL"
          fi

          echo "final-backend-url=$BACKEND_URL" >> $GITHUB_OUTPUT

      - name: Generate environment configuration
        id: generate-env
        uses: ./.github/actions/generate-frontend-env
        with:
          environment: ${{ needs.validate-access.outputs.env-name }}
          pr-number: ${{ github.event.pull_request.number }}
          build-mode: 'preview'
          api-endpoint: ${{ steps.resolve-backend.outputs.final-backend-url }}
          custom-domain-name: ${{ vars.CUSTOM_DOMAIN_NAME }}
          hosted-zone-id: ${{ vars.HOSTED_ZONE_ID }}
          parameter-store-path: '/macro-ai/development/api-key'
          api-key: ${{ secrets.API_KEY }}
          backend-stack-name: ${{ needs.validate-access.outputs.backend-stack-name }}
          resolution-method: 'artifact-based'
          output-file: '.env.preview'
          include-build-metadata: 'true'
          validate-variables: 'true'
          debug: 'false'

      - name: Debug .env.preview (sanitized)
        if: always()
        run: |
          echo "### .env.preview (sanitized)" >> "$GITHUB_STEP_SUMMARY"
          if [ -f apps/client-ui/.env.preview ]; then
            sed -E 's/^(.*(SECRET|TOKEN|PASSWORD|API_KEY|KEY)=).*/\1<masked>/' apps/client-ui/.env.preview \
              >> "$GITHUB_STEP_SUMMARY"
          else
            echo "(apps/client-ui/.env.preview not found)" >> "$GITHUB_STEP_SUMMARY"
            echo "Contents of apps/client-ui:" >> "$GITHUB_STEP_SUMMARY"
            ls -la apps/client-ui >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Verify no unauthorized .env files present
        run: |
          echo "üîç Checking for unexpected .env files in apps/client-ui"
          cd apps/client-ui
          FOUND=$(ls -1a .env* 2>/dev/null | grep -v '^.env.preview$' || true)
          if [[ -n "$FOUND" ]]; then
            echo "‚ùå Unauthorized .env files found in apps/client-ui:"
            echo "$FOUND"
            echo "Only .env.preview generated by CI is allowed."
            exit 1
          else
            echo "‚úÖ No unauthorized .env files detected"
          fi

      - name: Generate Amplify configuration
        run: |
          cd apps/client-ui

          ENV_NAME="${{ needs.validate-access.outputs.env-name }}"

          # Set environment variables for configuration generation
          export PR_NUMBER="${{ github.event.pull_request.number }}"
          export ENVIRONMENT_NAME="${ENV_NAME}"
          export BUILD_MODE="preview"
          export GITHUB_SHA="${{ github.sha }}"
          export GITHUB_REF_NAME="${{ github.ref_name }}"
          export GITHUB_PR_NUMBER="${{ github.event.pull_request.number }}"



          export PNPM_VERSION="${{ env.PNPM_VERSION }}"

          # Load environment variables from .env.preview using temporary file approach
          TEMP_ENV_FILE=$(mktemp)
          if grep '^[A-Za-z_][A-Za-z0-9_]*=' .env.preview > "$TEMP_ENV_FILE"; then
            echo "Found environment variables in .env.preview"
          else
            echo "No environment variables found in .env.preview"
            touch "$TEMP_ENV_FILE"
          fi

          # Export variables safely without sourcing (handles spaces, parentheses)
          if [[ -s "$TEMP_ENV_FILE" ]]; then
            while IFS= read -r line; do
              # Skip empty lines and comments
              [[ -z "$line" || "${line:0:1}" == "#" ]] && continue

              # Only process KEY=VALUE lines starting with a valid var name
              if [[ "$line" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
                key="${line%%=*}"
                value="${line#*=}"

                # Trim surrounding quotes if present
                if [[ "$value" == \"*\" && "$value" == *\" ]]; then
                  value="${value:1:-1}"
                elif [[ "$value" == \'*\' && "$value" == *\' ]]; then
                  value="${value:1:-1}"
                fi

                # Assign without eval, then export
                printf -v "$key" '%s' "$value"
                export "$key"
              fi
            done < "$TEMP_ENV_FILE"
            echo "‚úÖ Loaded $(wc -l < "$TEMP_ENV_FILE") environment variables"
          else
            echo "‚ö†Ô∏è No valid environment variables found in .env.preview"
          fi

          # Clean up temporary file
          rm -f "$TEMP_ENV_FILE"

          # Generate amplify.yml configuration using printf statements
          printf 'version: 1\n' > amplify.yml
          printf 'applications:\n' >> amplify.yml
          printf '  - appRoot: apps/client-ui\n' >> amplify.yml
          printf '    frontend:\n' >> amplify.yml
          printf '      phases:\n' >> amplify.yml
          printf '        preBuild:\n' >> amplify.yml
          printf '          commands:\n' >> amplify.yml
          printf '            - echo "Installing dependencies..."\n' >> amplify.yml
          printf '            - npm install -g pnpm@%s\n' "${PNPM_VERSION}" >> amplify.yml
          printf '            - pnpm install --frozen-lockfile\n' >> amplify.yml
          printf '        build:\n' >> amplify.yml
          printf '          commands:\n' >> amplify.yml
          printf '            - echo "Building React application..."\n' >> amplify.yml
          printf '            - pnpm run build\n' >> amplify.yml
          printf '      artifacts:\n' >> amplify.yml
          printf '        baseDirectory: dist\n' >> amplify.yml
          printf '        files:\n' >> amplify.yml
          printf '          - '\''**/*'\''\n' >> amplify.yml
          printf '      cache:\n' >> amplify.yml
          printf '        paths:\n' >> amplify.yml
          printf '          - node_modules/**/*\n' >> amplify.yml
          printf '          - .pnpm-store/**/*\n' >> amplify.yml

          echo "‚úÖ Generated amplify.yml configuration"

      - name: Build React application
        run: |
          cd apps/client-ui

          # Load environment variables using temporary file approach
          TEMP_ENV_FILE=$(mktemp)
          if grep '^[A-Za-z_][A-Za-z0-9_]*=' .env.preview > "$TEMP_ENV_FILE"; then
            echo "Found environment variables in .env.preview"
          else
            echo "No environment variables found in .env.preview"
            touch "$TEMP_ENV_FILE"
          fi

          if [[ -s "$TEMP_ENV_FILE" ]]; then
            while IFS= read -r line; do
              [[ -z "$line" || "${line:0:1}" == "#" ]] && continue
              if [[ "$line" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
                key="${line%%=*}"
                value="${line#*=}"
                if [[ "$value" == \"*\" && "$value" == *\" ]]; then
                  value="${value:1:-1}"
                elif [[ "$value" == \'*\' && "$value" == *\' ]]; then
                  value="${value:1:-1}"
                fi
                printf -v "$key" '%s' "$value"
                export "$key"
              fi
            done < "$TEMP_ENV_FILE"
            echo "‚úÖ Loaded environment variables for build"
          fi

          # Clean up temporary file
          rm -f "$TEMP_ENV_FILE"

          # Build the application
          echo "üî® Building React application..."
          pnpm run build

          echo "‚úÖ Build completed successfully"

          # Verify build output
          if [[ -d "dist" && -f "dist/index.html" ]]; then
            echo "‚úÖ Build artifacts verified"
            echo "üìä Build size: $(du -sh dist)"
          else
            echo "‚ùå Build verification failed"
            exit 1
          fi

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build-${{ needs.validate-access.outputs.env-name }}
          path: apps/client-ui/dist/
          retention-days: 7

    outputs:
      env-name: ${{ needs.validate-access.outputs.env-name }}
      amplify-app-id: ${{ needs.check-frontend-changes.outputs.existing-amplify-app-id }}
      backend-url: ${{ needs.validate-access.outputs.backend-url }}
      backend-stack-name: ${{ needs.validate-access.outputs.backend-stack-name }}
      frontend-url: ${{ needs.validate-access.outputs.frontend-url }}
      target-user: ${{ needs.validate-access.outputs.target-user }}

  # Deploy to AWS Amplify
  deploy-frontend:
    name: Deploy to AWS Amplify
    runs-on: ubuntu-latest
    needs: [build-frontend]
    if: always() && needs.build-frontend.result == 'success'

    outputs:
      app-url: ${{ steps.deploy.outputs.app-url }}
      app-id: ${{ steps.deploy.outputs.app-id }}

    permissions:
      id-token: write
      contents: read
      pull-requests: write
      issues: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-PreviewDeploy-Frontend-${{ github.run_id }}

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-build-${{ needs.build-frontend.outputs.env-name }}
          path: apps/client-ui/dist/

      - name: Deploy to Amplify
        id: deploy
        run: |
          cd apps/client-ui

          ENV_NAME="${{ needs.build-frontend.outputs.env-name }}"
          AMPLIFY_APP_NAME="macro-ai-frontend-${ENV_NAME}"

          # Use pre-calculated Amplify App ID from build-frontend
          APP_ID="${{ needs.build-frontend.outputs.amplify-app-id }}"

          echo "üöÄ Deploying to Amplify app: ${AMPLIFY_APP_NAME}"
          echo "üì± Using pre-calculated App ID: ${APP_ID}"

          # Verify the app exists (create if needed)
          if [[ -z "$APP_ID" ]]; then
            echo "üì± Creating new Amplify app: ${AMPLIFY_APP_NAME}"

            # Create new Amplify app
            APP_ID=$(aws amplify create-app \
              --name "${AMPLIFY_APP_NAME}" \
              --description "Frontend preview for PR #${{ github.event.pull_request.number }}" \
              --platform WEB \
              --region ${{ env.AWS_REGION }} \
              --query 'app.appId' \
              --output text)

            echo "‚úÖ Created Amplify app with ID: ${APP_ID}"
          else
            echo "‚úÖ Using pre-calculated Amplify app with ID: ${APP_ID}"
          fi

          # Create or update branch
          # Sanitize branch for safe use; keep original for Amplify API calls
          BRANCH_NAME="${{ github.head_ref }}"
          SANITIZED_BRANCH="${BRANCH_NAME//\//-}"
          echo "üåø Setting up branch: ${BRANCH_NAME}"

          # Check if branch exists
          BRANCH_EXISTS=$(aws amplify list-branches \
            --app-id "$APP_ID" \
            --region ${{ env.AWS_REGION }} \
            --query "branches[?branchName=='${BRANCH_NAME}'].branchName" \
            --output text 2>/dev/null || echo "")

          if [[ -z "$BRANCH_EXISTS" || "$BRANCH_EXISTS" == "None" ]]; then
            echo "üå± Creating new branch: ${BRANCH_NAME}"
            aws amplify create-branch \
              --app-id "$APP_ID" \
              --branch-name "${BRANCH_NAME}" \
              --description "Preview branch for PR #${{ github.event.pull_request.number }}" \
              --region ${{ env.AWS_REGION }}
          else
            echo "‚úÖ Branch already exists: ${BRANCH_NAME}"
          fi

          # Manual deployment flow (no repo connection required)
          echo "üöÄ Starting manual deployment via create-deployment..."

          # Ensure build artifacts exist and zip them
          if [[ -d "dist" ]]; then
            (cd dist && zip -qr ../build.zip .)
          else
            echo "‚ùå Build artifacts not found in apps/client-ui/dist"
            exit 1
          fi

          # Request a deployment to obtain jobId and pre-signed upload URL
          DEPLOY_JSON=$(aws amplify create-deployment \
            --app-id "$APP_ID" \
              --branch-name "${BRANCH_NAME}" \
            --region "${{ env.AWS_REGION }}")
          JOB_ID=$(echo "$DEPLOY_JSON" | jq -r '.jobId')
          UPLOAD_URL=$(echo "$DEPLOY_JSON" | jq -r '.zipUploadUrl')

          if [[ -z "$JOB_ID" || -z "$UPLOAD_URL" || "$JOB_ID" == "null" || "$UPLOAD_URL" == "null" ]]; then
            echo "‚ùå Failed to create deployment or retrieve upload URL"
            exit 1
          fi

          echo "üìã Deployment job ID: ${JOB_ID}"
          echo "‚¨ÜÔ∏è Uploading build.zip to pre-signed URL"
          curl -sS -X PUT -H "Content-Type: application/zip" --upload-file build.zip "$UPLOAD_URL"

          # Start the deployment
          aws amplify start-deployment \
            --app-id "$APP_ID" \
            --branch-name "${BRANCH_NAME}" \
            --job-id "$JOB_ID" \
            --region ${{ env.AWS_REGION }}

          # Wait for deployment to complete (polling get-job since Amplify has no waiters)
          echo "‚è≥ Waiting for deployment to complete..."
          MAX_ATTEMPTS=90; SLEEP=10
          for ((i=1;i<=MAX_ATTEMPTS;i++)); do
            STATUS=$(aws amplify get-job \
              --app-id "$APP_ID" \
              --branch-name "${BRANCH_NAME}" \
              --job-id "$JOB_ID" \
              --region ${{ env.AWS_REGION }} \
              --query 'job.summary.status' \
              --output text)
            echo "üîé Attempt $i/$MAX_ATTEMPTS: status=${STATUS}"
            if [[ "$STATUS" == "SUCCEED" || "$STATUS" == "FAILED" || "$STATUS" == "CANCELLED" ]]; then
              break
            fi
            sleep $SLEEP
          done

          # Get deployment status
          JOB_STATUS=$(aws amplify get-job \
            --app-id "$APP_ID" \
            --branch-name "${BRANCH_NAME}" \
            --job-id "$JOB_ID" \
            --region ${{ env.AWS_REGION }} \
            --query 'job.summary.status' \
            --output text)

          if [[ "$JOB_STATUS" == "SUCCEED" ]]; then
            # Sanitize branch for Amplify subdomain: replace '/' with '-'
            SANITIZED_BRANCH="${BRANCH_NAME//\//-}"
            DEFAULT_APP_URL="https://${SANITIZED_BRANCH}.${APP_ID}.amplifyapp.com/"
            echo "‚úÖ Deployment successful!"
            echo "üåê Default Frontend URL: ${DEFAULT_APP_URL}"

            # Configure custom domain if available
            CUSTOM_DOMAIN_NAME="${{ env.CUSTOM_DOMAIN_NAME }}"
            HOSTED_ZONE_ID="${{ env.HOSTED_ZONE_ID }}"
            FINAL_APP_URL="$DEFAULT_APP_URL"

            if [[ -n "$CUSTOM_DOMAIN_NAME" && -n "$HOSTED_ZONE_ID" ]]; then
              echo "üåê Configuring custom domain: $CUSTOM_DOMAIN_NAME"
              echo "üìÇ Current working directory: $(pwd)"
              echo "üìÅ Checking script existence..."

              if [[ -f "scripts/configure-amplify-custom-domain.sh" ]]; then
                echo "‚úÖ Script found: scripts/configure-amplify-custom-domain.sh"
                ls -la scripts/configure-amplify-custom-domain.sh
              else
                echo "‚ùå Script not found at: scripts/configure-amplify-custom-domain.sh"
                echo "üìÅ Available files in scripts directory:"
                ls -la scripts/ || echo "Scripts directory not found"
                exit 1
              fi

              # Use the custom domain configuration script (relative to current directory)
              chmod +x scripts/configure-amplify-custom-domain.sh

              CUSTOM_SUBDOMAIN="pr-${{ github.event.pull_request.number }}.${CUSTOM_DOMAIN_NAME}"

              # Check if this is likely a first-time domain setup by looking for existing validation records
              EXISTING_VALIDATION_RECORDS=$(aws route53 list-resource-record-sets \
                --hosted-zone-id "$HOSTED_ZONE_ID" \
                --query "ResourceRecordSets[?contains(Name, '_') && contains(Name, '${CUSTOM_DOMAIN_NAME}') && Type=='CNAME'].Name" \
                --output text 2>/dev/null || echo "")

              if [[ -n "$EXISTING_VALIDATION_RECORDS" ]]; then
                echo "‚úÖ Found existing validation records - using fast deployment"
                WAIT_FLAG="--no-wait"
              else
                echo "üîÑ First-time domain setup detected - will wait for verification"
                WAIT_FLAG=""
              fi

              if scripts/configure-amplify-custom-domain.sh \
                --app-id "$APP_ID" \
                --domain "$CUSTOM_SUBDOMAIN" \
                --hosted-zone-id "$HOSTED_ZONE_ID" \
                --environment "preview" \
                --branch "$BRANCH_NAME" \
                $WAIT_FLAG; then

                FINAL_APP_URL="https://${CUSTOM_SUBDOMAIN}/"
                echo "‚úÖ Custom domain configured successfully!"
                echo "üåê Custom Frontend URL: ${FINAL_APP_URL}"
                echo "üìù Note: SSL certificate verification may take a few minutes"
              else
                echo "‚ö†Ô∏è Custom domain configuration failed, using default URL"
                echo "üåê Fallback Frontend URL: ${DEFAULT_APP_URL}"
              fi
            else
              echo "üìù No custom domain configured, using default Amplify URL"
            fi

            {
              echo "app-id=${APP_ID}"
              echo "app-url=${FINAL_APP_URL}"
              echo "job-id=${JOB_ID}"
              echo "deployment-status=success"
            } >> "$GITHUB_OUTPUT"
          else
            echo "‚ùå Deployment failed with status: ${JOB_STATUS}"
            echo "deployment-status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

  # Summary job to show what was deployed
  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs:
      [
        validate-access,
        deploy-backend-preview,
        deploy-frontend,
        handle-existing-frontend,
      ]
    if: always() && (needs.deploy-backend-preview.result == 'success' || needs.deploy-frontend.result == 'success' || needs.handle-existing-frontend.result == 'success')

    permissions:
      pull-requests: write
      issues: write

    steps:
      - name: Generate deployment summary
        run: |
          echo "üöÄ Preview deployment completed successfully!"
          echo "Backend: ${{ needs.deploy-backend-preview.result == 'success' && 'Deployed' || 'Skipped' }}"
          echo "Frontend: ${{ needs.deploy-frontend.result == 'success' && 'Deployed' || 'Skipped' }}"
          echo ""
          echo "üìã Deployment Results:"
          echo "- Backend deployment: ${{ needs.deploy-backend-preview.result }}"
          echo "- Frontend deployment: ${{ needs.deploy-frontend.result }}"

      - name: Comment on PR with deployment details
        if: needs.deploy-frontend.result == 'success' || needs.handle-existing-frontend.result == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const frontendDeployed = '${{ needs.deploy-frontend.result }}' === 'success';
            const frontendReused = '${{ needs.handle-existing-frontend.result }}' === 'success';
            const backendDeployed = '${{ needs.deploy-backend-preview.result }}' === 'success';

            // Get frontend details - check both deployment and existing app
            let appUrl, appId;
            if (frontendDeployed) {
              appUrl = '${{ needs.deploy-frontend.outputs.app-url }}';
              appId = '${{ needs.deploy-frontend.outputs.app-id }}';
            } else if (frontendReused) {
              appUrl = '${{ needs.handle-existing-frontend.outputs.app-url }}';
              appId = '${{ needs.handle-existing-frontend.outputs.amplify-app-id }}';
            }
            const envName = '${{ needs.validate-access.outputs.env-name }}';

            // Get backend URL - use actual deployed URL if backend was deployed, otherwise use pre-calculated URL
            let backendUrl;
            let backendStack;

            if (backendDeployed) {
              backendUrl = '${{ needs.deploy-backend-preview.outputs.api-endpoint }}';
              backendStack = '${{ needs.deploy-backend-preview.outputs.stack-name }}';
            } else {
              // Use pre-calculated URLs from validate-access (pattern-based or fallback)
              backendUrl = '${{ needs.validate-access.outputs.backend-url }}';
              backendStack = '${{ needs.validate-access.outputs.backend-stack-name }}';
            }

            const comment = `## üöÄ Preview Environment Deployed Successfully!

            ### üåê Preview URLs
            - **Frontend**: [${appUrl}](${appUrl})
            - **Backend API**: ${backendUrl || 'Not deployed'}

            ### üìã Deployment Details
            - **Environment**: \`${envName}\`
            - **Amplify App ID**: \`${appId}\`
            - **Branch**: \`${{ github.head_ref }}\`
            - **Backend Status**: ${backendDeployed ? '‚úÖ Deployed' : '‚è≠Ô∏è Skipped (no changes)'}
            - **Frontend Status**: ${frontendDeployed ? '‚úÖ Deployed' : frontendReused ? 'üîÑ Reused (no changes)' : '‚ùå Failed'}

            ### üîó Quick Links
            - [AWS Amplify Console](https://console.aws.amazon.com/amplify/home?region=${{ env.AWS_REGION }}#/${appId})
            ${backendStack ? `- [Backend Stack](https://console.aws.amazon.com/cloudformation/home?region=${{ env.AWS_REGION }}#/stacks/stackinfo?stackId=${backendStack})` : ''}

            ---
            *This preview environment will be automatically cleaned up when the PR is closed/merged.*

            > ‚ö†Ô∏è **Note**: If this is the first deployment with custom domains, there may be a delay before the URLs become accessible due to SSL certificate validation and DNS propagation (typically 5-15 minutes).`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
