name: Deploy PR Preview Environment

on:
  pull_request:
    types: [opened, reopened, synchronize]
    branches: [develop, main]
    paths:
      - 'infrastructure/**'
      - 'apps/express-api/**'
      - 'apps/client-ui/**'
      - '.github/workflows/deploy-preview.yml'
      - '.github/workflows/deploy-frontend-preview.yml'
      - '.github/actions/check-codeowner/**'
      - '.github/actions/discover-backend/**'
      - '.github/actions/generate-frontend-env/**'

permissions:
  contents: read
  actions: read
  pull-requests: write
  issues: write

env:
  AWS_REGION: us-east-1
  NODE_VERSION: '20'
  PNPM_VERSION: '10.14.0'
  # CDK environment variables
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  CDK_DEFAULT_ACCOUNT: ${{ secrets.AWS_ACCOUNT_ID }}
  CDK_DEFAULT_REGION: us-east-1

jobs:
  # Check if PR author is a code owner and from same repo
  validate-access:
    name: Validate PR Access
    runs-on: ubuntu-latest
    outputs:
      is-owner: ${{ steps.codeowner-check.outputs.is-owner }}
      target-user: ${{ steps.codeowner-check.outputs.target-user }}
      is-same-repo: ${{ steps.repo-check.outputs.is-same-repo }}
      should-deploy: ${{ steps.decision.outputs.should-deploy }}
      env-name: ${{ steps.env-name.outputs.env-name }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Check repository ownership
        id: repo-check
        run: |
          if [[ "${{ github.event.pull_request.head.repo.full_name }}" == "${{ github.repository }}" ]]; then
            echo "is-same-repo=true" >> $GITHUB_OUTPUT
            echo "‚úÖ PR from same repository: ${{ github.event.pull_request.head.repo.full_name }}"
          else
            echo "is-same-repo=false" >> $GITHUB_OUTPUT
            echo "‚ùå PR from forked repository: ${{ github.event.pull_request.head.repo.full_name }}"
          fi

      - name: Check code ownership
        id: codeowner-check
        uses: ./.github/actions/check-codeowner
        with:
          mode: 'pr'
          base-ref: ${{ github.event.pull_request.base.ref }}

      - name: Generate environment name
        id: env-name
        run: |
          ENV_NAME="pr-${{ github.event.pull_request.number }}"
          echo "env-name=${ENV_NAME}" >> $GITHUB_OUTPUT
          echo "Environment name: ${ENV_NAME}"

      - name: Make deployment decision
        id: decision
        run: |
          IS_SAME_REPO="${{ steps.repo-check.outputs.is-same-repo }}"
          IS_OWNER="${{ steps.codeowner-check.outputs.is-owner }}"

          if [[ "${IS_SAME_REPO}" == "true" && "${IS_OWNER}" == "true" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Deployment approved: same-repo PR by code owner ${{ steps.codeowner-check.outputs.target-user }}"
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            echo "‚ùå Deployment blocked:"
            echo "  - Same repo: ${IS_SAME_REPO}"
            echo "  - Code owner: ${IS_OWNER}"
            echo "  - User: ${{ steps.codeowner-check.outputs.target-user }}"
          fi

  # Build Lambda package for deployment
  build-lambda:
    name: Build Lambda Package
    runs-on: ubuntu-latest
    needs: [validate-access, check-backend-changes]
    if: needs.validate-access.outputs.should-deploy == 'true' && needs.check-backend-changes.outputs.has-backend-changes == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Build Lambda package
        run: |
          cd apps/express-api
          pnpm install --frozen-lockfile
          pnpm build:lambda
          pnpm bundle:lambda
          pnpm package:lambda

      - name: Upload Lambda package
        uses: actions/upload-artifact@v4
        with:
          name: lambda-package-${{ needs.validate-access.outputs.env-name }}
          path: apps/express-api/dist/lambda.zip
          retention-days: 7

  # Deploy ephemeral PR environment
  deploy-preview:
    name: Deploy Preview Environment
    runs-on: ubuntu-latest
    needs: [validate-access, build-lambda, check-backend-changes]
    if: needs.validate-access.outputs.should-deploy == 'true' && needs.check-backend-changes.outputs.has-backend-changes == 'true'
    environment: development

    permissions:
      id-token: write
      contents: read
      pull-requests: write
      issues: write

    outputs:
      api-endpoint: ${{ steps.outputs.outputs.api-endpoint }}
      stack-name: ${{ steps.stack-info.outputs.stack-name }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install AWS CDK CLI globally
        run: pnpm add -g aws-cdk@2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download Lambda package
        uses: actions/download-artifact@v4
        with:
          name: lambda-package-${{ needs.validate-access.outputs.env-name }}
          path: apps/express-api/dist/

      - name: Generate stack information
        id: stack-info
        run: |
          ENV_NAME="${{ needs.validate-access.outputs.env-name }}"
          # Capitalize first letter for stack name (pr-123 -> Pr-123)
          STACK_NAME="MacroAi$(echo "${ENV_NAME}" | sed 's/^./\U&/')Stack"
          echo "stack-name=${STACK_NAME}" >> $GITHUB_OUTPUT
          echo "Stack name: ${STACK_NAME}"

      - name: Deploy infrastructure
        run: |
          cd infrastructure
          pnpm install --frozen-lockfile
          pnpm build

          echo "üöÄ Deploying ephemeral environment: ${{ needs.validate-access.outputs.env-name }}"
          echo "üì¶ Stack: ${{ steps.stack-info.outputs.stack-name }}"
          echo "üë§ Requested by: ${{ needs.validate-access.outputs.target-user }}"

          # Make deploy script executable and run it
          chmod +x scripts/deploy.sh
          ./scripts/deploy.sh
        env:
          CDK_DEPLOY_ENV: ${{ needs.validate-access.outputs.env-name }}
          CDK_DEPLOY_SCALE: 'hobby'
          AWS_REGION: ${{ env.AWS_REGION }}
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
          NODE_ENV: 'production'

      - name: Get deployment outputs
        id: outputs
        run: |
          STACK_NAME="${{ steps.stack-info.outputs.stack-name }}"

          # Get API endpoint from CloudFormation outputs
          API_ENDPOINT=$(aws cloudformation describe-stacks \
            --stack-name "${STACK_NAME}" \
            --query "Stacks[0].Outputs[?OutputKey=='ApiEndpoint'].OutputValue" \
            --output text 2>/dev/null || echo "")

          if [[ -n "${API_ENDPOINT}" ]]; then
            echo "api-endpoint=${API_ENDPOINT}" >> $GITHUB_OUTPUT
            echo "‚úÖ API endpoint: ${API_ENDPOINT}"
          else
            echo "‚ö†Ô∏è Could not retrieve API endpoint"
          fi

      - name: Health check
        id: health-check
        run: |
          API_ENDPOINT="${{ steps.outputs.outputs.api-endpoint }}"

          if [[ -n "${API_ENDPOINT}" ]]; then
            echo "üîç Testing health endpoint: ${API_ENDPOINT}api/health"
            
            # Wait a moment for deployment to stabilize
            sleep 10
            
            # Test health endpoint with retries
            for i in {1..3}; do
              HEALTH_RESPONSE=$(curl -s -w "%{http_code}" "${API_ENDPOINT}api/health" 2>/dev/null || echo "000")
              if [[ "$HEALTH_RESPONSE" == *"200" ]]; then
                echo "health-status=healthy" >> $GITHUB_OUTPUT
                echo "‚úÖ Health check passed (attempt $i)"
                break
              else
                echo "‚ö†Ô∏è Health check failed (attempt $i): $HEALTH_RESPONSE"
                if [[ $i -eq 3 ]]; then
                  echo "health-status=unhealthy" >> $GITHUB_OUTPUT
                fi
                sleep 5
              fi
            done
          else
            echo "health-status=unknown" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Cannot perform health check - no API endpoint"
          fi

  # Comment on PR with deployment information
  comment-pr:
    name: Comment on PR
    runs-on: ubuntu-latest
    needs: [validate-access, deploy-preview]
    if: always() && needs.validate-access.outputs.should-deploy == 'true'

    permissions:
      pull-requests: write

    steps:
      - name: Create PR comment
        uses: actions/github-script@v7
        with:
          script: |
            const envName = '${{ needs.validate-access.outputs.env-name }}';
            const stackName = '${{ needs.deploy-preview.outputs.stack-name }}';
            const apiEndpoint = '${{ needs.deploy-preview.outputs.api-endpoint }}';
            const healthStatus = '${{ needs.deploy-preview.outputs.health-status }}';
            const deployResult = '${{ needs.deploy-preview.result }}';

            let comment = `## üöÄ Preview Environment Deployed\n\n`;
            comment += `**Environment:** \`${envName}\`\n`;
            comment += `**Stack:** \`${stackName}\`\n`;
            comment += `**Requested by:** @${{ needs.validate-access.outputs.target-user }}\n\n`;

            if (deployResult === 'success' && apiEndpoint) {
              comment += `### üåê Endpoints\n`;
              comment += `- **API:** ${apiEndpoint}api/\n`;
              comment += `- **Health:** ${apiEndpoint}api/health\n\n`;
              
              const healthIcon = healthStatus === 'healthy' ? '‚úÖ' : '‚ö†Ô∏è';
              comment += `### ${healthIcon} Health Status\n`;
              comment += `Health check: **${healthStatus}**\n\n`;
            } else {
              comment += `### ‚ùå Deployment Failed\n`;
              comment += `The preview environment deployment encountered an error. Check the workflow logs for details.\n\n`;
            }

            comment += `### üìã Environment Details\n`;
            comment += `- **Parameter Store:** \`/macro-ai/development\` (shared)\n`;
            comment += `- **Auto-cleanup:** When PR is closed/merged\n`;
            comment += `- **Manual cleanup:** Use \`teardown-dev.yml\` workflow\n\n`;
            comment += `---\n`;
            comment += `*This preview environment uses shared development secrets and will be automatically destroyed when the PR is closed.*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  # Handle blocked deployments (forked PRs or non-code-owners)
  explain-blocked:
    name: Explain Blocked Deployment
    runs-on: ubuntu-latest
    needs: validate-access
    if: needs.validate-access.outputs.should-deploy == 'false'

    permissions:
      pull-requests: write

    steps:
      - name: Comment on blocked PR
        uses: actions/github-script@v7
        with:
          script: |
            const isSameRepo = '${{ needs.validate-access.outputs.is-same-repo }}' === 'true';
            const isOwner = '${{ needs.validate-access.outputs.is-owner }}' === 'true';
            const targetUser = '${{ needs.validate-access.outputs.target-user }}';

            let comment = `## üö´ Preview Environment Deployment Blocked\n\n`;

            if (!isSameRepo) {
              comment += `### üîí Forked Repository\n`;
              comment += `This PR originates from a forked repository. For security reasons, automatic preview deployments are restricted to the main repository.\n\n`;
              comment += `**Options:**\n`;
              comment += `- A repository maintainer can manually deploy a preview using the \`deploy-forked-pr-preview.yml\` workflow\n`;
              comment += `- The preview will use trusted base repository code (not fork changes)\n\n`;
            }

            if (!isOwner) {
              comment += `### üë§ Code Owner Required\n`;
              comment += `User \`@${targetUser}\` is not listed as a code owner in \`.github/CODEOWNERS\`.\n\n`;
              comment += `**To enable automatic preview deployments:**\n`;
              comment += `- Add \`@${targetUser}\` to the \`.github/CODEOWNERS\` file\n`;
              comment += `- Or have a code owner create the PR\n\n`;
            }

            comment += `### üîç Current Status\n`;
            comment += `- **Same repository:** ${isSameRepo ? '‚úÖ' : '‚ùå'}\n`;
            comment += `- **Code owner:** ${isOwner ? '‚úÖ' : '‚ùå'}\n`;
            comment += `- **User:** \`@${targetUser}\`\n\n`;
            comment += `---\n`;
            comment += `*For questions about preview environments, contact a repository maintainer.*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  # Change detection jobs (run in parallel to optimize workflow)
  check-backend-changes:
    name: Check Backend Changes
    runs-on: ubuntu-latest
    needs: [validate-access]
    outputs:
      has-backend-changes: ${{ steps.check.outputs.has-backend-changes }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for backend changes
        id: check
        run: |
          # Check if there are any backend-related changes in this PR
          BACKEND_CHANGES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | grep -E '^infrastructure/|^apps/express-api/|^\.github/workflows/deploy-preview\.yml|^\.github/actions/check-codeowner/' || true)

          if [[ -n "$BACKEND_CHANGES" ]]; then
            echo "‚úÖ Backend changes detected:"
            echo "$BACKEND_CHANGES"
            echo "has-backend-changes=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No backend changes detected, skipping backend deployment"
            echo "has-backend-changes=false" >> $GITHUB_OUTPUT
          fi

  check-frontend-changes:
    name: Check Frontend Changes
    runs-on: ubuntu-latest
    needs: [validate-access]
    outputs:
      has-frontend-changes: ${{ steps.check.outputs.has-frontend-changes }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for frontend changes
        id: check
        run: |
          # Check if there are any frontend-related changes in this PR
          FRONTEND_CHANGES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | grep -E '^apps/client-ui/|^\.github/actions/(discover-backend|generate-frontend-env)/' || true)

          if [[ -n "$FRONTEND_CHANGES" ]]; then
            echo "‚úÖ Frontend changes detected:"
            echo "$FRONTEND_CHANGES"
            echo "has-frontend-changes=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No frontend changes detected, skipping frontend deployment"
            echo "has-frontend-changes=false" >> $GITHUB_OUTPUT
          fi

  # Discover backend environment for frontend
  discover-backend-for-frontend:
    name: Discover Backend for Frontend
    runs-on: ubuntu-latest
    needs:
      [
        validate-access,
        check-backend-changes,
        check-frontend-changes,
        deploy-preview,
      ]
    # Run if frontend has changes, regardless of whether backend was deployed or not
    if: |
      always() &&
      needs.validate-access.outputs.should-deploy == 'true' &&
      needs.check-frontend-changes.outputs.has-frontend-changes == 'true' &&
      (needs.deploy-preview.result == 'success' || needs.deploy-preview.result == 'skipped')

    outputs:
      api-endpoint: ${{ steps.discover.outputs.api-endpoint }}
      stack-name: ${{ steps.discover.outputs.stack-name }}
      backend-found: ${{ steps.discover.outputs.backend-found }}
      resolution-method: ${{ steps.discover.outputs.resolution-method }}
      fallback-used: ${{ steps.discover.outputs.fallback-used }}
      connectivity-status: ${{ steps.discover.outputs.connectivity-status }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Discover backend environment
        id: discover
        uses: ./.github/actions/discover-backend
        with:
          environment: ${{ needs.validate-access.outputs.env-name }}
          pr-number: ${{ github.event.pull_request.number }}
          validate-connectivity: 'true'
          aws-region: ${{ env.AWS_REGION }}
          debug: 'false'

  # Build the React frontend
  build-frontend:
    name: Build React Frontend
    runs-on: ubuntu-latest
    needs:
      [validate-access, check-frontend-changes, discover-backend-for-frontend]
    if: needs.validate-access.outputs.should-deploy == 'true' && needs.check-frontend-changes.outputs.has-frontend-changes == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'
          cache-dependency-path: 'apps/client-ui/pnpm-lock.yaml'

      - name: Install dependencies
        run: |
          cd apps/client-ui
          pnpm install --frozen-lockfile

      - name: Generate API client package
        run: |
          echo "üîß Generating API client package from OpenAPI specification"

          # Install dependencies for express-api to generate OpenAPI spec
          cd apps/express-api
          pnpm install --frozen-lockfile

          # Generate OpenAPI specification
          echo "üìã Generating OpenAPI specification..."
          pnpm run generate-swagger

          # Generate the API client package
          echo "üì¶ Generating API client package..."
          cd ../../packages/macro-ai-api-client
          pnpm install --frozen-lockfile
          pnpm run generate

          echo "‚úÖ API client package generated successfully"

      - name: Generate environment configuration
        id: generate-env
        uses: ./.github/actions/generate-frontend-env
        with:
          environment: ${{ needs.validate-access.outputs.env-name }}
          pr-number: ${{ github.event.pull_request.number }}
          build-mode: 'preview'
          api-endpoint: ${{ needs.discover-backend-for-frontend.outputs.api-endpoint }}
          api-key: ${{ secrets.API_KEY }}
          backend-stack-name: ${{ needs.discover-backend-for-frontend.outputs.stack-name }}
          resolution-method: ${{ needs.discover-backend-for-frontend.outputs.resolution-method }}
          output-file: '.env.preview'
          include-build-metadata: 'true'
          validate-variables: 'true'
          debug: 'false'

      - name: Generate Amplify configuration
        run: |
          cd apps/client-ui

          ENV_NAME="${{ needs.validate-access.outputs.env-name }}"

          # Set environment variables for configuration generation
          export PR_NUMBER="${{ github.event.pull_request.number }}"
          export ENVIRONMENT_NAME="${ENV_NAME}"
          export BUILD_MODE="preview"
          export GITHUB_SHA="${{ github.sha }}"
          export GITHUB_REF_NAME="${{ github.ref_name }}"
          export GITHUB_PR_NUMBER="${{ github.event.pull_request.number }}"

          # Load environment variables from .env.preview using temporary file approach
          TEMP_ENV_FILE=$(mktemp)
          grep '^[A-Za-z_][A-Za-z0-9_]*=' .env.preview > "$TEMP_ENV_FILE" || true

          # Source the temporary file
          if [[ -s "$TEMP_ENV_FILE" ]]; then
            set -a
            source "$TEMP_ENV_FILE"
            set +a
            echo "‚úÖ Loaded $(wc -l < "$TEMP_ENV_FILE") environment variables"
          else
            echo "‚ö†Ô∏è No valid environment variables found in .env.preview"
          fi

          # Clean up temporary file
          rm -f "$TEMP_ENV_FILE"

          # Generate amplify.yml configuration
          cat > amplify.yml << EOF
          version: 1
          applications:
            - appRoot: apps/client-ui
              frontend:
                phases:
                  preBuild:
                    commands:
                      - echo "Installing dependencies..."
                      - npm install -g pnpm@${PNPM_VERSION}
                      - pnpm install --frozen-lockfile
                  build:
                    commands:
                      - echo "Building React application..."
                      - pnpm run build
                artifacts:
                  baseDirectory: dist
                  files:
                    - '**/*'
                cache:
                  paths:
                    - node_modules/**/*
                    - .pnpm-store/**/*
          EOF

          echo "‚úÖ Generated amplify.yml configuration"

      - name: Build React application
        run: |
          cd apps/client-ui

          # Load environment variables using temporary file approach
          TEMP_ENV_FILE=$(mktemp)
          grep '^[A-Za-z_][A-Za-z0-9_]*=' .env.preview > "$TEMP_ENV_FILE" || true

          if [[ -s "$TEMP_ENV_FILE" ]]; then
            set -a
            source "$TEMP_ENV_FILE"
            set +a
            echo "‚úÖ Loaded environment variables for build"
          fi

          # Clean up temporary file
          rm -f "$TEMP_ENV_FILE"

          # Build the application
          echo "üî® Building React application..."
          pnpm run build

          echo "‚úÖ Build completed successfully"

          # Verify build output
          if [[ -d "dist" && -f "dist/index.html" ]]; then
            echo "‚úÖ Build artifacts verified"
            echo "üìä Build size: $(du -sh dist)"
          else
            echo "‚ùå Build verification failed"
            exit 1
          fi

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build-${{ needs.validate-access.outputs.env-name }}
          path: apps/client-ui/dist/
          retention-days: 7

  # Deploy to AWS Amplify
  deploy-frontend:
    name: Deploy to AWS Amplify
    runs-on: ubuntu-latest
    needs: [validate-access, check-frontend-changes, build-frontend]
    if: needs.validate-access.outputs.should-deploy == 'true' && needs.check-frontend-changes.outputs.has-frontend-changes == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-build-${{ needs.validate-access.outputs.env-name }}
          path: apps/client-ui/dist/

      - name: Deploy to Amplify
        id: deploy
        run: |
          cd apps/client-ui

          ENV_NAME="${{ needs.validate-access.outputs.env-name }}"
          AMPLIFY_APP_NAME="macro-ai-frontend-${ENV_NAME}"

          echo "üöÄ Deploying to Amplify app: ${AMPLIFY_APP_NAME}"

          # Check if Amplify app exists
          APP_ID=$(aws amplify list-apps --region ${{ env.AWS_REGION }} \
            --query "apps[?name=='${AMPLIFY_APP_NAME}'].appId" \
            --output text 2>/dev/null || echo "")

          if [[ -z "$APP_ID" || "$APP_ID" == "None" ]]; then
            echo "üì± Creating new Amplify app: ${AMPLIFY_APP_NAME}"

            # Create new Amplify app
            APP_ID=$(aws amplify create-app \
              --name "${AMPLIFY_APP_NAME}" \
              --description "Frontend preview for PR #${{ github.event.pull_request.number }}" \
              --repository "https://github.com/${{ github.repository }}" \
              --platform WEB \
              --region ${{ env.AWS_REGION }} \
              --query 'app.appId' \
              --output text)

            echo "‚úÖ Created Amplify app with ID: ${APP_ID}"
          else
            echo "‚úÖ Using existing Amplify app with ID: ${APP_ID}"
          fi

          # Create or update branch
          BRANCH_NAME="${{ github.head_ref }}"
          echo "üåø Setting up branch: ${BRANCH_NAME}"

          # Check if branch exists
          BRANCH_EXISTS=$(aws amplify list-branches \
            --app-id "$APP_ID" \
            --region ${{ env.AWS_REGION }} \
            --query "branches[?branchName=='${BRANCH_NAME}'].branchName" \
            --output text 2>/dev/null || echo "")

          if [[ -z "$BRANCH_EXISTS" || "$BRANCH_EXISTS" == "None" ]]; then
            echo "üå± Creating new branch: ${BRANCH_NAME}"
            aws amplify create-branch \
              --app-id "$APP_ID" \
              --branch-name "${BRANCH_NAME}" \
              --description "Preview branch for PR #${{ github.event.pull_request.number }}" \
              --region ${{ env.AWS_REGION }}
          else
            echo "‚úÖ Branch already exists: ${BRANCH_NAME}"
          fi

          # Start deployment
          echo "üöÄ Starting deployment..."
          JOB_ID=$(aws amplify start-job \
            --app-id "$APP_ID" \
            --branch-name "${BRANCH_NAME}" \
            --job-type RELEASE \
            --region ${{ env.AWS_REGION }} \
            --query 'jobSummary.jobId' \
            --output text)

          echo "üìã Deployment job ID: ${JOB_ID}"

          # Wait for deployment to complete
          echo "‚è≥ Waiting for deployment to complete..."
          aws amplify wait job-complete \
            --app-id "$APP_ID" \
            --branch-name "${BRANCH_NAME}" \
            --job-id "$JOB_ID" \
            --region ${{ env.AWS_REGION }}

          # Get deployment status
          JOB_STATUS=$(aws amplify get-job \
            --app-id "$APP_ID" \
            --branch-name "${BRANCH_NAME}" \
            --job-id "$JOB_ID" \
            --region ${{ env.AWS_REGION }} \
            --query 'job.summary.status' \
            --output text)

          if [[ "$JOB_STATUS" == "SUCCEED" ]]; then
            # Get the app URL
            APP_URL="https://${BRANCH_NAME}.${APP_ID}.amplifyapp.com"
            echo "‚úÖ Deployment successful!"
            echo "üåê Frontend URL: ${APP_URL}"

            echo "app-id=${APP_ID}" >> $GITHUB_OUTPUT
            echo "app-url=${APP_URL}" >> $GITHUB_OUTPUT
            echo "job-id=${JOB_ID}" >> $GITHUB_OUTPUT
            echo "deployment-status=success" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Deployment failed with status: ${JOB_STATUS}"
            echo "deployment-status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Comment on PR with frontend URL
        if: steps.deploy.outputs.deployment-status == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const appUrl = '${{ steps.deploy.outputs.app-url }}';
            const appId = '${{ steps.deploy.outputs.app-id }}';
            const jobId = '${{ steps.deploy.outputs.job-id }}';
            const envName = '${{ needs.validate-access.outputs.env-name }}';

            const comment = `## üöÄ Frontend Preview Deployed Successfully!

            ### üåê Preview URLs
            - **Frontend**: [${appUrl}](${appUrl})
            - **Backend API**: ${{ needs.discover-backend-for-frontend.outputs.api-endpoint }}

            ### üìã Deployment Details
            - **Environment**: \`${envName}\`
            - **Amplify App ID**: \`${appId}\`
            - **Job ID**: \`${jobId}\`
            - **Branch**: \`${{ github.head_ref }}\`

            ### üîó Quick Links
            - [AWS Amplify Console](https://console.aws.amazon.com/amplify/home?region=${{ env.AWS_REGION }}#/${appId})
            - [Backend Stack](https://console.aws.amazon.com/cloudformation/home?region=${{ env.AWS_REGION }}#/stacks/stackinfo?stackId=${{ needs.discover-backend-for-frontend.outputs.stack-name }})

            ---
            *This preview environment will be automatically cleaned up when the PR is closed/merged.*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  # Summary job to show what was deployed
  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs:
      [
        validate-access,
        check-backend-changes,
        check-frontend-changes,
        deploy-preview,
        deploy-frontend,
      ]
    if: always() && needs.validate-access.outputs.should-deploy == 'true'

    steps:
      - name: Generate deployment summary
        run: |
          echo "## üìã Deployment Summary for PR #${{ github.event.pull_request.number }}"
          echo ""

          # Backend deployment status
          BACKEND_CHANGES="${{ needs.check-backend-changes.outputs.has-backend-changes }}"
          BACKEND_RESULT="${{ needs.deploy-preview.result }}"

          echo "### üîß Backend Deployment"
          if [[ "$BACKEND_CHANGES" == "true" ]]; then
            if [[ "$BACKEND_RESULT" == "success" ]]; then
              echo "‚úÖ **Backend deployed successfully** - Changes detected and deployed"
            elif [[ "$BACKEND_RESULT" == "failure" ]]; then
              echo "‚ùå **Backend deployment failed** - Check logs for details"
            else
              echo "‚è≥ **Backend deployment in progress** - Status: $BACKEND_RESULT"
            fi
          else
            echo "‚è≠Ô∏è **Backend deployment skipped** - No backend changes detected"
            echo "‚ÑπÔ∏è Using existing backend environment from previous deployment"
          fi
          echo ""

          # Frontend deployment status
          FRONTEND_CHANGES="${{ needs.check-frontend-changes.outputs.has-frontend-changes }}"
          FRONTEND_RESULT="${{ needs.deploy-frontend.result }}"

          echo "### üé® Frontend Deployment"
          if [[ "$FRONTEND_CHANGES" == "true" ]]; then
            if [[ "$FRONTEND_RESULT" == "success" ]]; then
              echo "‚úÖ **Frontend deployed successfully** - Changes detected and deployed"
            elif [[ "$FRONTEND_RESULT" == "failure" ]]; then
              echo "‚ùå **Frontend deployment failed** - Check logs for details"
            else
              echo "‚è≥ **Frontend deployment in progress** - Status: $FRONTEND_RESULT"
            fi
          else
            echo "‚è≠Ô∏è **Frontend deployment skipped** - No frontend changes detected"
            echo "‚ÑπÔ∏è Existing frontend deployment remains active"
          fi
          echo ""

          # Optimization summary
          echo "### ‚ö° Optimization Summary"
          if [[ "$BACKEND_CHANGES" == "true" && "$FRONTEND_CHANGES" == "true" ]]; then
            echo "üîÑ **Full deployment** - Both backend and frontend changes detected"
          elif [[ "$BACKEND_CHANGES" == "true" && "$FRONTEND_CHANGES" == "false" ]]; then
            echo "üîß **Backend-only deployment** - Optimized to skip frontend"
          elif [[ "$BACKEND_CHANGES" == "false" && "$FRONTEND_CHANGES" == "true" ]]; then
            echo "üé® **Frontend-only deployment** - Optimized to skip backend rebuild"
          else
            echo "‚è≠Ô∏è **No deployments needed** - No changes detected in either component"
          fi

          echo ""
          echo "---"
          echo "*This summary shows the optimized deployment strategy based on detected changes.*"
